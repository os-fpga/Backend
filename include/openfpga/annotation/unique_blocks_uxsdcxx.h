#pragma once
/*
 * This file is generated by uxsdcxx 0.1.0.
 * https://github.com/duck2/uxsdcxx
 * Modify only if your build process doesn't involve regenerating this file.
 *
 * Cmdline: uxsdcxx/uxsdcxx.py /home/serge/bes/13oct/Backend/OpenFPGA/libs/libopenfpgacapnproto/gen/unique_blocks.xsd
 * Input file: /home/serge/bes/13oct/Backend/OpenFPGA/libs/libopenfpgacapnproto/gen/unique_blocks.xsd
 * md5sum of input file: 1db9d740309076fa51f61413bae1e072
 */

#include <functional>


#include <bitset>
#include <cassert>
#include <cstring>
#include <iostream>
#include <sstream>
#include <memory>
#include <string>
#include <vector>

#include <stddef.h>
#include <stdint.h>
#include "pugixml.hpp"

#include "unique_blocks_uxsdcxx_interface.h"
/* All uxsdcxx functions and structs live in this namespace. */
namespace uxsd {

/**
 * Internal function for getting line and column number from file based on
 * byte offset.
 */
inline void get_line_number(const char *filename, std::ptrdiff_t offset, int * line, int * col);

[[noreturn]] inline void noreturn_report(const std::function<void(const char *)> * report_error, const char *msg) {
    (*report_error)(msg);
    throw std::runtime_error("Unreachable!");
}

/* Declarations for internal load functions for the complex types. */
template <class T, typename Context>
inline void load_instance(const pugi::xml_node &root, T &out, Context &context, const std::function<void(const char*)> *report_error, ptrdiff_t *offset_debug);
inline void load_instance_required_attributes(const pugi::xml_node &root, unsigned int * x, unsigned int * y, const std::function<void(const char*)> * report_error);
template <class T, typename Context>
inline void load_block(const pugi::xml_node &root, T &out, Context &context, const std::function<void(const char*)> *report_error, ptrdiff_t *offset_debug);
inline void load_block_required_attributes(const pugi::xml_node &root, enum_type * type, unsigned int * x, unsigned int * y, const std::function<void(const char*)> * report_error);
template <class T, typename Context>
inline void load_unique_blocks(const pugi::xml_node &root, T &out, Context &context, const std::function<void(const char*)> *report_error, ptrdiff_t *offset_debug);

/* Declarations for internal write functions for the complex types. */
template <class T>
inline void write_block(T &in, std::ostream &os, const void *data, void *iter);
template <class T>
inline void write_unique_blocks(T &in, std::ostream &os, const void *data, void *iter);

/* Load function for the root element. */
template <class T, typename Context>
inline void load_unique_blocks_xml(T &out, Context &context, const char * filename, std::istream &is){
	pugi::xml_document doc;
	pugi::xml_parse_result result = doc.load(is);
	if(!result) {
		int line, col;
		get_line_number(filename, result.offset, &line, &col);
		std::stringstream msg;
		msg << "Unable to load XML file '" << filename << "', ";
		msg << result.description() << " (line: " << line;
		msg << " col: " << col << ")";		out.error_encountered(filename, line, msg.str().c_str());
	}
	ptrdiff_t offset_debug = 0;
	std::function<void(const char *)> report_error = [filename, &out, &offset_debug](const char * message) {
		int line, col;
		get_line_number(filename, offset_debug, &line, &col);
		out.error_encountered(filename, line, message);
		// If error_encountered didn't throw, throw now to unwind.
		throw std::runtime_error(message);
	};
	out.start_load(&report_error);
	
	for(pugi::xml_node node= doc.first_child(); node; node = node.next_sibling()){
		if(std::strcmp(node.name(), "unique_blocks") == 0){
			/* If errno is set up to this point, it messes with strtol errno checking. */
			errno = 0;
			load_unique_blocks(node, out, context, &report_error, &offset_debug);
		} else {
			offset_debug = node.offset_debug();
			report_error(("Invalid root-level element " + std::string(node.name())).c_str());
		}
	}
	out.finish_load();
}

/* Write function for the root element. */
template <class T, typename Context>
inline void write_unique_blocks_xml(T &in, Context &context, std::ostream &os){
	in.start_write();
	os << "<unique_blocks";
	os << ">\n";
	write_unique_blocks(in, os, context);
	os << "</unique_blocks>\n";
	in.finish_write();
}


typedef const uint32_t __attribute__((aligned(1))) triehash_uu32;
typedef const uint64_t __attribute__((aligned(1))) triehash_uu64;
static_assert(alignof(triehash_uu32) == 1, "Unaligned 32-bit access not found.");
static_assert(alignof(triehash_uu64) == 1, "Unaligned 64-bit access not found.");
#if __BYTE_ORDER__ == __ORDER_LITTLE_ENDIAN__
#define onechar(c, s, l) (((uint64_t)(c)) << (s))
#else
#define onechar(c, s, l) (((uint64_t)(c)) << (l-8-s))
#endif

/* Tokens for attribute and node names. */

enum class atok_t_instance {X, Y};
constexpr const char *atok_lookup_t_instance[] = {"x", "y"};

enum class gtok_t_block {INSTANCE};
constexpr const char *gtok_lookup_t_block[] = {"instance"};
enum class atok_t_block {TYPE, X, Y};
constexpr const char *atok_lookup_t_block[] = {"type", "x", "y"};

enum class gtok_t_unique_blocks {BLOCK};
constexpr const char *gtok_lookup_t_unique_blocks[] = {"block"};

/* Internal lexers. These convert the PugiXML node names to input tokens. */
inline atok_t_instance lex_attr_t_instance(const char *in, const std::function<void(const char *)> * report_error){
	unsigned int len = strlen(in);
	switch(len){
	case 1:
		switch(in[0]){
		case onechar('x', 0, 8):
			return atok_t_instance::X;
		break;
		case onechar('y', 0, 8):
			return atok_t_instance::Y;
		break;
		default: break;
		}
		break;
	default: break;
	}
	noreturn_report(report_error, ("Found unrecognized attribute " + std::string(in) + " of <instance>.").c_str());
}

inline gtok_t_block lex_node_t_block(const char *in, const std::function<void(const char *)> *report_error){
	unsigned int len = strlen(in);
	switch(len){
	case 8:
		switch(*((triehash_uu64*)&in[0])){
		case onechar('i', 0, 64) | onechar('n', 8, 64) | onechar('s', 16, 64) | onechar('t', 24, 64) | onechar('a', 32, 64) | onechar('n', 40, 64) | onechar('c', 48, 64) | onechar('e', 56, 64):
			return gtok_t_block::INSTANCE;
		break;
		default: break;
		}
		break;
	default: break;
	}
	noreturn_report(report_error, ("Found unrecognized child " + std::string(in) + " of <block>.").c_str());
}
inline atok_t_block lex_attr_t_block(const char *in, const std::function<void(const char *)> * report_error){
	unsigned int len = strlen(in);
	switch(len){
	case 1:
		switch(in[0]){
		case onechar('x', 0, 8):
			return atok_t_block::X;
		break;
		case onechar('y', 0, 8):
			return atok_t_block::Y;
		break;
		default: break;
		}
		break;
	case 4:
		switch(*((triehash_uu32*)&in[0])){
		case onechar('t', 0, 32) | onechar('y', 8, 32) | onechar('p', 16, 32) | onechar('e', 24, 32):
			return atok_t_block::TYPE;
		break;
		default: break;
		}
		break;
	default: break;
	}
	noreturn_report(report_error, ("Found unrecognized attribute " + std::string(in) + " of <block>.").c_str());
}

inline gtok_t_unique_blocks lex_node_t_unique_blocks(const char *in, const std::function<void(const char *)> *report_error){
	unsigned int len = strlen(in);
	switch(len){
	case 5:
		switch(*((triehash_uu32*)&in[0])){
		case onechar('b', 0, 32) | onechar('l', 8, 32) | onechar('o', 16, 32) | onechar('c', 24, 32):
			switch(in[4]){
			case onechar('k', 0, 8):
				return gtok_t_unique_blocks::BLOCK;
			break;
			default: break;
			}
		break;
		default: break;
		}
		break;
	default: break;
	}
	noreturn_report(report_error, ("Found unrecognized child " + std::string(in) + " of <unique_blocks>.").c_str());
}

/**
 * Internal error function for xs:choice and xs:sequence validators.
 */
[[noreturn]] inline void dfa_error(const char *wrong, const int *states, const char * const *lookup, int len, const std::function<void(const char *)> * report_error);

/**
 * Internal error function for attribute validators.
 */
template<std::size_t N>
[[noreturn]] inline void attr_error(std::bitset<N> astate, const char * const *lookup, const std::function<void(const char *)> * report_error);


/* Lookup tables for enums. */
constexpr const char *lookup_type[] = {"UXSD_INVALID", "cbx", "cby", "sb"};

/* Lexers(string->token functions) for enums. */
inline enum_type lex_enum_type(const char *in, bool throw_on_invalid, const std::function<void(const char *)> * report_error){
	unsigned int len = strlen(in);
	switch(len){
	case 2:
		switch(in[0]){
		case onechar('s', 0, 8):
			switch(in[1]){
			case onechar('b', 0, 8):
				return enum_type::SB;
			break;
			default: break;
			}
		break;
		default: break;
		}
		break;
	case 3:
		switch(in[0]){
		case onechar('c', 0, 8):
			switch(in[1]){
			case onechar('b', 0, 8):
				switch(in[2]){
				case onechar('x', 0, 8):
					return enum_type::CBX;
				break;
				case onechar('y', 0, 8):
					return enum_type::CBY;
				break;
				default: break;
				}
			break;
			default: break;
			}
		break;
		default: break;
		}
		break;
	default: break;
	}
	if(throw_on_invalid)
		noreturn_report(report_error, ("Found unrecognized enum value " + std::string(in) + " of enum_type.").c_str());
	return enum_type::UXSD_INVALID;
}


/* Internal loading functions, which validate and load a PugiXML DOM tree into memory. */
inline unsigned int load_unsigned_int(const char *in, const std::function<void(const char *)> * report_error){
	unsigned int out;
	out = std::strtoul(in, NULL, 10);
	if(errno != 0)
		noreturn_report(report_error, ("Invalid value `" + std::string(in) + "` when loading into a unsigned int.").c_str());
	return out;
}
inline void load_instance_required_attributes(const pugi::xml_node &root, unsigned int * x, unsigned int * y, const std::function<void(const char *)> * report_error){
	std::bitset<2> astate = 0;
	for(pugi::xml_attribute attr = root.first_attribute(); attr; attr = attr.next_attribute()){
		atok_t_instance in = lex_attr_t_instance(attr.name(), report_error);
		if(astate[(int)in] == 0) astate[(int)in] = 1;
		else noreturn_report(report_error, ("Duplicate attribute " + std::string(attr.name()) + " in <instance>.").c_str());
		switch(in){
		case atok_t_instance::X:
			*x = load_unsigned_int(attr.value(), report_error);
			break;
		case atok_t_instance::Y:
			*y = load_unsigned_int(attr.value(), report_error);
			break;
		default: break; /* Not possible. */
		}
	}
	std::bitset<2> test_astate = astate | std::bitset<2>(0b00);
	if(!test_astate.all()) attr_error(test_astate, atok_lookup_t_instance, report_error);
}

inline void load_block_required_attributes(const pugi::xml_node &root, enum_type * type, unsigned int * x, unsigned int * y, const std::function<void(const char *)> * report_error){
	std::bitset<3> astate = 0;
	for(pugi::xml_attribute attr = root.first_attribute(); attr; attr = attr.next_attribute()){
		atok_t_block in = lex_attr_t_block(attr.name(), report_error);
		if(astate[(int)in] == 0) astate[(int)in] = 1;
		else noreturn_report(report_error, ("Duplicate attribute " + std::string(attr.name()) + " in <block>.").c_str());
		switch(in){
		case atok_t_block::TYPE:
			*type = lex_enum_type(attr.value(), true, report_error);
			break;
		case atok_t_block::X:
			*x = load_unsigned_int(attr.value(), report_error);
			break;
		case atok_t_block::Y:
			*y = load_unsigned_int(attr.value(), report_error);
			break;
		default: break; /* Not possible. */
		}
	}
	std::bitset<3> test_astate = astate | std::bitset<3>(0b000);
	if(!test_astate.all()) attr_error(test_astate, atok_lookup_t_block, report_error);
}
template<class T, typename Context>
inline void load_instance(const pugi::xml_node &root, T &out, Context &context, const std::function<void(const char*)> *report_error, ptrdiff_t *offset_debug){
	(void)root;
	(void)out;
	(void)context;
	(void)report_error;
	// Update current file offset in case an error is encountered.
	*offset_debug = root.offset_debug();


	if(root.first_child().type() == pugi::node_element)
		noreturn_report(report_error, "Unexpected child element in <instance>.");

}

constexpr int NUM_T_BLOCK_STATES = 1;
constexpr const int NUM_T_BLOCK_INPUTS = 1;
constexpr int gstate_t_block[NUM_T_BLOCK_STATES][NUM_T_BLOCK_INPUTS] = {
	{0},
};
template<class T, typename Context>
inline void load_block(const pugi::xml_node &root, T &out, Context &context, const std::function<void(const char*)> *report_error, ptrdiff_t *offset_debug){
	(void)root;
	(void)out;
	(void)context;
	(void)report_error;
	// Update current file offset in case an error is encountered.
	*offset_debug = root.offset_debug();


	// Preallocate arrays by counting child nodes (if any)
	size_t instance_count = 0;
	{
		int next, state=0;
		for(pugi::xml_node node = root.first_child(); node; node = node.next_sibling()) {
			*offset_debug = node.offset_debug();
			gtok_t_block in = lex_node_t_block(node.name(), report_error);
			next = gstate_t_block[state][(int)in];
			if(next == -1)
				dfa_error(gtok_lookup_t_block[(int)in], gstate_t_block[state], gtok_lookup_t_block, 1, report_error);
			state = next;
			switch(in) {
			case gtok_t_block::INSTANCE:
				instance_count += 1;
				break;
			default: break; /* Not possible. */
			}
		}
		
		out.preallocate_block_instance(context, instance_count);
	}
	int next, state=0;
	for(pugi::xml_node node = root.first_child(); node; node = node.next_sibling()){
		*offset_debug = node.offset_debug();
		gtok_t_block in = lex_node_t_block(node.name(), report_error);
		next = gstate_t_block[state][(int)in];
		if(next == -1)
			dfa_error(gtok_lookup_t_block[(int)in], gstate_t_block[state], gtok_lookup_t_block, 1, report_error);
		state = next;
		switch(in){
		case gtok_t_block::INSTANCE:
			{
				unsigned int instance_x;
				memset(&instance_x, 0, sizeof(instance_x));
				unsigned int instance_y;
				memset(&instance_y, 0, sizeof(instance_y));
				load_instance_required_attributes(node, &instance_x, &instance_y, report_error);
				auto child_context = out.add_block_instance(context, instance_x, instance_y);
				load_instance(node, out, child_context, report_error, offset_debug);
				out.finish_block_instance(child_context);
			}
			break;
		default: break; /* Not possible. */
		}
	}
	if(state != 0) dfa_error("end of input", gstate_t_block[state], gtok_lookup_t_block, 1, report_error);

}

constexpr int NUM_T_UNIQUE_BLOCKS_STATES = 2;
constexpr const int NUM_T_UNIQUE_BLOCKS_INPUTS = 1;
constexpr int gstate_t_unique_blocks[NUM_T_UNIQUE_BLOCKS_STATES][NUM_T_UNIQUE_BLOCKS_INPUTS] = {
	{0},
	{0},
};
template<class T, typename Context>
inline void load_unique_blocks(const pugi::xml_node &root, T &out, Context &context, const std::function<void(const char*)> *report_error, ptrdiff_t *offset_debug){
	(void)root;
	(void)out;
	(void)context;
	(void)report_error;
	// Update current file offset in case an error is encountered.
	*offset_debug = root.offset_debug();

	if(root.first_attribute())
		noreturn_report(report_error, "Unexpected attribute in <unique_blocks>.");

	// Preallocate arrays by counting child nodes (if any)
	size_t block_count = 0;
	{
		int next, state=1;
		for(pugi::xml_node node = root.first_child(); node; node = node.next_sibling()) {
			*offset_debug = node.offset_debug();
			gtok_t_unique_blocks in = lex_node_t_unique_blocks(node.name(), report_error);
			next = gstate_t_unique_blocks[state][(int)in];
			if(next == -1)
				dfa_error(gtok_lookup_t_unique_blocks[(int)in], gstate_t_unique_blocks[state], gtok_lookup_t_unique_blocks, 1, report_error);
			state = next;
			switch(in) {
			case gtok_t_unique_blocks::BLOCK:
				block_count += 1;
				break;
			default: break; /* Not possible. */
			}
		}
		
		out.preallocate_unique_blocks_block(context, block_count);
	}
	int next, state=1;
	for(pugi::xml_node node = root.first_child(); node; node = node.next_sibling()){
		*offset_debug = node.offset_debug();
		gtok_t_unique_blocks in = lex_node_t_unique_blocks(node.name(), report_error);
		next = gstate_t_unique_blocks[state][(int)in];
		if(next == -1)
			dfa_error(gtok_lookup_t_unique_blocks[(int)in], gstate_t_unique_blocks[state], gtok_lookup_t_unique_blocks, 1, report_error);
		state = next;
		switch(in){
		case gtok_t_unique_blocks::BLOCK:
			{
				enum_type block_type;
				memset(&block_type, 0, sizeof(block_type));
				unsigned int block_x;
				memset(&block_x, 0, sizeof(block_x));
				unsigned int block_y;
				memset(&block_y, 0, sizeof(block_y));
				load_block_required_attributes(node, &block_type, &block_x, &block_y, report_error);
				auto child_context = out.add_unique_blocks_block(context, block_type, block_x, block_y);
				load_block(node, out, child_context, report_error, offset_debug);
				out.finish_unique_blocks_block(child_context);
			}
			break;
		default: break; /* Not possible. */
		}
	}
	if(state != 0) dfa_error("end of input", gstate_t_unique_blocks[state], gtok_lookup_t_unique_blocks, 1, report_error);

}


/* Internal writing functions, which uxsdcxx uses to write out a class. */
template<class T, typename Context>
inline void write_block(T &in, std::ostream &os, Context &context){
	(void)in;
	(void)os;
	(void)context;
	{
		for(size_t i=0, n=in.num_block_instance(context); i<n; i++){
			auto child_context = in.get_block_instance(i, context);
			os << "<instance";
			os << " x=\"" << in.get_instance_x(child_context) << "\"";
			os << " y=\"" << in.get_instance_y(child_context) << "\"";
			os << "/>\n";
		}
	}
}

template<class T, typename Context>
inline void write_unique_blocks(T &in, std::ostream &os, Context &context){
	(void)in;
	(void)os;
	(void)context;
	{
		for(size_t i=0, n=in.num_unique_blocks_block(context); i<n; i++){
			auto child_context = in.get_unique_blocks_block(i, context);
			os << "<block";
			os << " type=\"" << lookup_type[(int)in.get_block_type(child_context)] << "\"";
			os << " x=\"" << in.get_block_x(child_context) << "\"";
			os << " y=\"" << in.get_block_y(child_context) << "\"";
			os << ">";
			write_block(in, os, child_context);
			os << "</block>\n";
		}
	}
}

inline void dfa_error(const char *wrong, const int *states, const char * const *lookup, int len, const std::function<void(const char *)> * report_error){
	std::vector<std::string> expected;
	for(int i=0; i<len; i++){
		if(states[i] != -1) expected.push_back(lookup[i]);
	}

	std::string expected_or = expected[0];
	for(unsigned int i=1; i<expected.size(); i++)
		expected_or += std::string(" or ") + expected[i];

	noreturn_report(report_error, ("Expected " + expected_or + ", found " + std::string(wrong)).c_str());
}

template<std::size_t N>
inline void attr_error(std::bitset<N> astate, const char * const *lookup, const std::function<void(const char *)> * report_error){
	std::vector<std::string> missing;
	for(unsigned int i=0; i<N; i++){
		if(astate[i] == 0) missing.push_back(lookup[i]);
	}

	std::string missing_and = missing[0];
	for(unsigned int i=1; i<missing.size(); i++)
		missing_and += std::string(", ") + missing[i];

	noreturn_report(report_error, ("Didn't find required attributes " + missing_and + ".").c_str());
}

inline void get_line_number(const char *filename, std::ptrdiff_t target_offset, int * line, int * col) {
	std::unique_ptr<FILE,decltype(&fclose)> f(fopen(filename, "rb"), fclose);

	if (!f) {
		throw std::runtime_error(std::string("Failed to open file") + filename);
	}

	int current_line = 1;
	std::ptrdiff_t offset = 0;
	std::ptrdiff_t last_line_offset = 0;
	std::ptrdiff_t current_line_offset = 0;

	char buffer[1024];
	std::size_t size;

	while ((size = fread(buffer, 1, sizeof(buffer), f.get())) > 0) {
		for (std::size_t i = 0; i < size; ++i) {
			if (buffer[i] == '\n') {
				current_line += 1;
				last_line_offset = current_line_offset;
				current_line_offset = offset + i;

				if(target_offset < current_line_offset) {
					if(target_offset < last_line_offset) {
						throw std::runtime_error("Assertion violation");
					}

					*line = current_line - 1;
					*col = target_offset - last_line_offset;
					return;
				}
			}
		}

		offset += size;
	}

	*line = current_line;
	*col = target_offset - current_line_offset;
}


} /* namespace uxsd */
