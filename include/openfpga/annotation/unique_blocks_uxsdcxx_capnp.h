#pragma once
/*
 * This file is generated by uxsdcxx 0.1.0.
 * https://github.com/duck2/uxsdcxx
 * Modify only if your build process doesn't involve regenerating this file.
 *
 * Cmdline: uxsdcxx/uxsdcap.py /home/serge/bes/13oct/Backend/OpenFPGA/libs/libopenfpgacapnproto/gen/unique_blocks.xsd unique_blocks_capnproto_generate/unique_blocks_uxsdcxx.h unique_blocks_capnproto_generate/unique_blocks_uxsdcxx_capnp.h unique_blocks_capnproto_generate/unique_blocks_uxsdcxx_interface.h /home/serge/bes/13oct/Backend/OpenFPGA/libs/libopenfpgacapnproto/gen
 * Input file: /home/serge/bes/13oct/Backend/OpenFPGA/libs/libopenfpgacapnproto/gen/unique_blocks.xsd
 * md5sum of input file: 1db9d740309076fa51f61413bae1e072
 */

#include <functional>

#include <stdexcept>
#include <tuple>
#include <vector>
#include <sstream>
#include <limits>
#include "capnp/serialize.h"
#include "unique_blocks_uxsdcxx.capnp.h"
#include "unique_blocks_uxsdcxx_interface.h"

/* All uxsdcxx functions and structs live in this namespace. */
namespace uxsd {
/* Declarations for internal load functions for the complex types. */
template <class T, typename Context>
void load_instance_capnp_type(const ucap::Instance::Reader &root, T &out, Context &context, const std::function<void(const char*)> * report_error, std::vector<std::pair<const char *, size_t>> * stack);
template <class T, typename Context>
void load_block_capnp_type(const ucap::Block::Reader &root, T &out, Context &context, const std::function<void(const char*)> * report_error, std::vector<std::pair<const char *, size_t>> * stack);
template <class T, typename Context>
void load_unique_blocks_capnp_type(const ucap::UniqueBlocks::Reader &root, T &out, Context &context, const std::function<void(const char*)> * report_error, std::vector<std::pair<const char *, size_t>> * stack);

/* Declarations for internal write functions for the complex types. */
template <class T, typename Context>
inline void write_block_capnp_type(T &in, ucap::Block::Builder &root, Context &context);
template <class T, typename Context>
inline void write_unique_blocks_capnp_type(T &in, ucap::UniqueBlocks::Builder &root, Context &context);

/* Enum conversions from uxsd to ucap */
inline enum_type conv_enum_type(ucap::Type e, const std::function<void(const char *)> * report_error) {
	switch(e) {
	case ucap::Type::UXSD_INVALID:
		return enum_type::UXSD_INVALID;
	case ucap::Type::CBX:
		return enum_type::CBX;
	case ucap::Type::CBY:
		return enum_type::CBY;
	case ucap::Type::SB:
		return enum_type::SB;
	default:
		(*report_error)("Unknown enum_type");
		throw std::runtime_error("Unreachable!");
	}
}

inline ucap::Type conv_to_enum_type(enum_type e) {
	switch(e) {
	case enum_type::UXSD_INVALID:
		return ucap::Type::UXSD_INVALID;
	case enum_type::CBX:
		return ucap::Type::CBX;
	case enum_type::CBY:
		return ucap::Type::CBY;
	case enum_type::SB:
		return ucap::Type::SB;
	default:
		throw std::runtime_error("Unknown enum_type");
	}
}


/* Load function for the root element. */
template <class T, typename Context>
inline void load_unique_blocks_capnp(T &out, kj::ArrayPtr<const ::capnp::word> data, Context &context, const char * filename){
	/* Remove traversal limits. */
	::capnp::ReaderOptions opts = ::capnp::ReaderOptions();
	opts.traversalLimitInWords = std::numeric_limits<uint64_t>::max();
	::capnp::FlatArrayMessageReader reader(data, opts);
	auto root = reader.getRoot<ucap::UniqueBlocks>();
	std::vector<std::pair<const char*, size_t>> stack;
	stack.reserve(20);
	stack.push_back(std::make_pair("root", 0));

	std::function<void(const char *)> report_error = [filename, &out, &stack](const char *message){
		std::stringstream msg;
		msg << message << std::endl;
		msg << "Error occured at ";
		for(size_t i = 0; i < stack.size(); ++i) {
			msg << stack[i].first << "[" << stack[i].second << "]";
			if(i+1 < stack.size()) {
				msg << " . ";
			}
		}
		out.error_encountered(filename, -1, msg.str().c_str());
	};
	out.start_load(&report_error);
	load_unique_blocks_capnp_type(root, out, context, &report_error, &stack);
	out.finish_load();
}

/* Write function for the root element. */
template <class T, typename Context>
inline void write_unique_blocks_capnp(T &in, Context &context, ucap::UniqueBlocks::Builder &root) {
	in.start_write();
	write_unique_blocks_capnp_type(in, root, context);
	in.finish_write();
}


/* Internal loading functions, which validate and load a PugiXML DOM tree into memory. */
template<class T, typename Context>
inline void load_instance_capnp_type(const ucap::Instance::Reader &root, T &out, Context &context, const std::function<void(const char*)> * report_error, std::vector<std::pair<const char *, size_t>> * stack){
	(void)root;
	(void)out;
	(void)context;
	(void)report_error;
	(void)stack;

}

template<class T, typename Context>
inline void load_block_capnp_type(const ucap::Block::Reader &root, T &out, Context &context, const std::function<void(const char*)> * report_error, std::vector<std::pair<const char *, size_t>> * stack){
	(void)root;
	(void)out;
	(void)context;
	(void)report_error;
	(void)stack;

	stack->push_back(std::make_pair("getInstance", 0));
	{
		auto data = root.getInstances();
		out.preallocate_block_instance(context, data.size());
		for(const auto & el : data) {
			auto child_context = out.add_block_instance(context, el.getX(), el.getY());
			load_instance_capnp_type(el, out, child_context, report_error, stack);
			out.finish_block_instance(child_context);
			stack->back().second += 1;
		}
	}
	stack->pop_back();
}

template<class T, typename Context>
inline void load_unique_blocks_capnp_type(const ucap::UniqueBlocks::Reader &root, T &out, Context &context, const std::function<void(const char*)> * report_error, std::vector<std::pair<const char *, size_t>> * stack){
	(void)root;
	(void)out;
	(void)context;
	(void)report_error;
	(void)stack;

	stack->push_back(std::make_pair("getBlock", 0));
	{
		auto data = root.getBlocks();
		out.preallocate_unique_blocks_block(context, data.size());
		for(const auto & el : data) {
			auto child_context = out.add_unique_blocks_block(context, conv_enum_type(el.getType(), report_error), el.getX(), el.getY());
			load_block_capnp_type(el, out, child_context, report_error, stack);
			out.finish_unique_blocks_block(child_context);
			stack->back().second += 1;
		}
	}
	stack->pop_back();
}


/* Internal writing functions, which uxsdcxx uses to write out a class. */
template<class T, typename Context>
inline void write_block_capnp_type(T &in, ucap::Block::Builder &root, Context &context) {
	(void)in;
	(void)root;

	size_t num_block_instances = in.num_block_instance(context);
	auto block_instances = root.initInstances(num_block_instances);
	for(size_t i = 0; i < num_block_instances; i++) {
		auto block_instance = block_instances[i];
		auto child_context = in.get_block_instance(i, context);
		block_instance.setX(in.get_instance_x(child_context));
		block_instance.setY(in.get_instance_y(child_context));
	}
}

template<class T, typename Context>
inline void write_unique_blocks_capnp_type(T &in, ucap::UniqueBlocks::Builder &root, Context &context) {
	(void)in;
	(void)root;

	size_t num_unique_blocks_blocks = in.num_unique_blocks_block(context);
	auto unique_blocks_blocks = root.initBlocks(num_unique_blocks_blocks);
	for(size_t i = 0; i < num_unique_blocks_blocks; i++) {
		auto unique_blocks_block = unique_blocks_blocks[i];
		auto child_context = in.get_unique_blocks_block(i, context);
		unique_blocks_block.setType(conv_to_enum_type(in.get_block_type(child_context)));
		unique_blocks_block.setX(in.get_block_x(child_context));
		unique_blocks_block.setY(in.get_block_y(child_context));
		write_block_capnp_type(in, unique_blocks_block, child_context);
	}
}


} /* namespace uxsd */
