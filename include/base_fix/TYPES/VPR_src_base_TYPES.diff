diff --git a/vpr/src/base/vpr_api.cpp b/vpr/src/base/vpr_api.cpp
index 5b7a45b85..f53b36ce8 100644
--- a/vpr/src/base/vpr_api.cpp
+++ b/vpr/src/base/vpr_api.cpp
@@ -372,18 +372,20 @@ bool vpr_flow(t_vpr_setup& vpr_setup, t_arch& arch) {
     }
 
 #ifdef VPR_USE_TBB
 
     /* Set this here, because tbb::global_control doesn't control anything once it's out of scope
      * (contrary to the name). */
     tbb::global_control c(tbb::global_control::max_allowed_parallelism, vpr_setup.num_workers);
 #endif
 
+    g_vpr_ctx.mutable_logic_levels().levelize();
+
     { //Pack
         bool pack_success = vpr_pack_flow(vpr_setup, arch);
 
         if (!pack_success) {
             return false; //Unimplementable
         }
     }
 
     // For the time being, we decided to create the flat graph after placement is done. Thus, the is_flat parameter for this function
diff --git a/vpr/src/base/vpr_context.h b/vpr/src/base/vpr_context.h
index 73dbc8b04..8dcdb6844 100644
--- a/vpr/src/base/vpr_context.h
+++ b/vpr/src/base/vpr_context.h
@@ -27,18 +27,20 @@
 #include "router_lookahead.h"
 #include "place_macro.h"
 #include "compressed_grid.h"
 #include "metadata_storage.h"
 #include "vpr_constraints.h"
 #include "noc_storage.h"
 #include "noc_traffic_flows.h"
 #include "noc_routing.h"
 
+#include "rsbe_utils.h" // rsbe::Levelized logic_levels_
+
 /**
  * @brief A Context is collection of state relating to a particular part of VPR
  *
  * This is a base class who's only purpose is to disable copying of contexts.
  * This ensures that attempting to use a context by value (instead of by reference)
  * will result in a compilation error.
  *
  * No data or member functions should be defined in this class!
  */
@@ -632,29 +634,39 @@ class VprContext : public Context {
     const FloorplanningContext& floorplanning() const { return constraints_; }
     FloorplanningContext& mutable_floorplanning() { return constraints_; }
 
     const NocContext& noc() const { return noc_; }
     NocContext& mutable_noc() { return noc_; }
 
     const PackingMultithreadingContext& packing_multithreading() const { return packing_multithreading_; }
     PackingMultithreadingContext& mutable_packing_multithreading() { return packing_multithreading_; }
 
+    const rsbe::Levelized& logic_levels() const { return logic_levels_; }
+    rsbe::Levelized& mutable_logic_levels() { return logic_levels_; }
+
   private:
     DeviceContext device_;
 
     AtomContext atom_;
 
     TimingContext timing_;
     PowerContext power_;
 
     ClusteringContext clustering_;
     ClusteringHelperContext helper_;
 
     PlacementContext placement_;
     RoutingContext routing_;
     FloorplanningContext constraints_;
     NocContext noc_;
 
     PackingMultithreadingContext packing_multithreading_;
+
+    /**
+     * @brief The Levelized class represents a graph that has been levelized, allowing efficient traversal and analysis.
+     * It provides methods to perform graph levelization, check if the graph has been levelized, and access information about
+     * nodes in each logic level and the total number of logic levels.
+     */
+    rsbe::Levelized logic_levels_;
 };
 
 #endif
diff --git a/vpr/src/base/vpr_types.h b/vpr/src/base/vpr_types.h
index a7528f8c8..76ecdf425 100644
--- a/vpr/src/base/vpr_types.h
+++ b/vpr/src/base/vpr_types.h
@@ -952,22 +952,25 @@ struct t_packer_opts {
     e_balance_block_type_util balance_block_type_utilization;
     std::vector<std::string> target_external_pin_util;
     bool prioritize_transitive_connectivity;
     std::vector<std::string> high_fanout_threshold;
     int transitive_fanout_threshold;
     int feasible_block_array_size;
     e_stage_action doPacking;
     enum e_packer_algorithm packer_algorithm;
     std::string device_layout;
+    std::string top_mod;
     e_timing_update_type timing_update_type;
     bool use_attraction_groups;
     int pack_num_moves;
     std::string pack_move_type;
+    bool use_partitioning_in_pack;
+    int number_of_molecules_in_partition;
 };
 
 /**
  * @brief Annealing schedule information for the placer.
  *
  * The schedule type is either USER_SCHED or AUTO_SCHED. Inner_num is
  * multiplied by num_blocks^4/3 to find the number of moves per temperature.
  * The remaining information is used only for USER_SCHED, and have
  * the obvious meanings.
@@ -1010,19 +1013,20 @@ struct t_annealing_sched {
  *              to reduce critical path delay.
  *
  * The default is to use CRITICALITY_TIMING_PLACE. BOUNDING_BOX_PLACE
  * is used when there is no timing information available (wiring only).
  * SLACK_TIMING_PLACE is mainly feasible during placement quench.
  */
 enum e_place_algorithm {
     BOUNDING_BOX_PLACE,
     CRITICALITY_TIMING_PLACE,
-    SLACK_TIMING_PLACE
+    SLACK_TIMING_PLACE,
+    CONGESTION_AWARE_PLACE
 };
 
 enum e_place_bounding_box_mode {
     AUTO_BB,
     CUBE_BB,
     PER_LAYER_BB
 };
 
 /**
@@ -1060,19 +1064,19 @@ class t_place_algorithm {
 
     //Equality operators
     bool operator==(const t_place_algorithm& rhs) const { return algo == rhs.algo; }
     bool operator==(e_place_algorithm rhs) const { return algo == rhs; }
     bool operator!=(const t_place_algorithm& rhs) const { return algo != rhs.algo; }
     bool operator!=(e_place_algorithm rhs) const { return algo != rhs; }
 
     ///@brief Check if the algorithm belongs to the timing driven category.
     inline bool is_timing_driven() const {
-        return algo == CRITICALITY_TIMING_PLACE || algo == SLACK_TIMING_PLACE;
+        return algo == CRITICALITY_TIMING_PLACE || algo == SLACK_TIMING_PLACE || algo== CONGESTION_AWARE_PLACE;
     }
 
     ///@brief Accessor: returns the underlying e_place_algorithm enum value.
     e_place_algorithm get() const { return algo; }
 
   private:
     ///@brief The underlying algorithm. Default set to CRITICALITY_TIMING_PLACE.
     e_place_algorithm algo = e_place_algorithm::CRITICALITY_TIMING_PLACE;
 };
@@ -1195,18 +1199,19 @@ enum class e_place_delta_delay_algorithm {
  *              True if subtiles should be specified when printing floorplan
  *              constraints. False if not.
  *
  *
  */
 struct t_placer_opts {
     t_place_algorithm place_algorithm;
     t_place_algorithm place_quench_algorithm;
     float timing_tradeoff;
+    float congestion_tradeoff;
     float place_cost_exp;
     int place_chan_width;
     enum e_pad_loc_type pad_loc_type;
     std::string constraints_file;
     std::string write_initial_place_file;
     enum pfreq place_freq;
     int recompute_crit_iter;
     int inner_loop_recompute_divider;
     int quench_recompute_divider;
@@ -1269,18 +1274,20 @@ struct t_placer_opts {
     e_place_delta_delay_algorithm place_delta_delay_matrix_calculation_method;
 
     /*
      * @brief enables the analytic placer.
      *
      * Once analytic placement is done, the result is passed through the quench phase
      * of the annealing placer for local improvement
      */
     bool enable_analytic_placer;
+    // Cascade Placer
+    bool enable_cascade_placer;
 };
 
 /* All the parameters controlling the router's operation are in this        *
  * structure.                                                               *
  * first_iter_pres_fac:  Present sharing penalty factor used for the        *
  *                 very first (congestion mapping) Pathfinder iteration.    *
  * initial_pres_fac:  Initial present sharing penalty factor for            *
  *                    Pathfinder; used to set pres_fac on 2nd iteration.    *
  * pres_fac_mult:  Amount by which pres_fac is multiplied each              *
