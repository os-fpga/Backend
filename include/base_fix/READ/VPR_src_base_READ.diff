diff --git a/vpr/src/base/read_circuit.cpp b/vpr/src/base/read_circuit.cpp
index ac46b3857..27f11552e 100644
--- a/vpr/src/base/read_circuit.cpp
+++ b/vpr/src/base/read_circuit.cpp
@@ -1,5 +1,5 @@
 #include "read_circuit.h"
-#include "read_blif.h"
+#include "read_blif_RS.h"
 #include "read_interchange_netlist.h"
 #include "atom_netlist.h"
 #include "atom_netlist_utils.h"
@@ -43,6 +43,14 @@ AtomNetlist read_and_process_circuit(e_circuit_format circuit_format, t_vpr_setu
             circuit_format = e_circuit_format::BLIF;
         } else if (name_ext[1] == ".eblif") {
             circuit_format = e_circuit_format::EBLIF;
+        } else if (name_ext[1] == ".v") {
+            circuit_format = e_circuit_format::VERILOG;
+        }  else if (name_ext[1] == ".edif") {
+            circuit_format = e_circuit_format::EDIF;
+        }  else if (name_ext[1] == ".edn") {
+            circuit_format = e_circuit_format::EDIF;
+        }  else if (name_ext[1] == ".edf") {
+            circuit_format = e_circuit_format::EDIF;
         }  else {
             VPR_FATAL_ERROR(VPR_ERROR_ATOM_NETLIST, "Failed to determine file format for '%s' expected .blif or .eblif extension",
                             circuit_file);
@@ -58,6 +66,20 @@ AtomNetlist read_and_process_circuit(e_circuit_format circuit_format, t_vpr_setu
             case e_circuit_format::EBLIF:
                 netlist = read_blif(circuit_format, circuit_file, user_models, library_models);
                 break;
+            case e_circuit_format::VERILOG:
+            #ifdef ENABLE_VERIFIC
+                circuit_format = e_circuit_format::EBLIF;
+                netlist = read_blif_from_vrilog(circuit_format, circuit_file, user_models, library_models, vpr_setup, top_mod);
+            #else
+                VPR_FATAL_ERROR(VPR_ERROR_ATOM_NETLIST,
+                                "Unable to identify circuit file format for '%s'. Expect [blif|eblif|fpga-interchange]! as verilog support is disabled\n",
+                                circuit_file);
+            #endif
+                break;
+            case e_circuit_format::EDIF:
+                circuit_format = e_circuit_format::EDIF;
+                netlist = read_blif_from_edif(circuit_format, circuit_file, user_models, library_models);
+                break;
             case e_circuit_format::FPGA_INTERCHANGE:
                 netlist = read_interchange_netlist(circuit_file, arch);
                 break;
diff --git a/vpr/src/base/read_circuit.h b/vpr/src/base/read_circuit.h
index 90be01a38..0521e0a00 100644
--- a/vpr/src/base/read_circuit.h
+++ b/vpr/src/base/read_circuit.h
@@ -7,7 +7,9 @@
 enum class e_circuit_format {
     AUTO,            ///<Infer from file extension
     BLIF,            ///<Strict structural BLIF
-    EBLIF,           ///<Structural blif with extensions
+    EBLIF, //Structural blif with extensions
+    VERILOG, // verilog netlist
+    EDIF,
     FPGA_INTERCHANGE ///<FPGA Interhange logical netlis format
 };
 
diff --git a/vpr/src/base/read_options.cpp b/vpr/src/base/read_options.cpp
index 240f2cbc2..c71112fe9 100644
--- a/vpr/src/base/read_options.cpp
+++ b/vpr/src/base/read_options.cpp
@@ -102,6 +102,14 @@ struct ParseCircuitFormat {
             conv_value.set_value(e_circuit_format::BLIF);
         else if (str == "eblif")
             conv_value.set_value(e_circuit_format::EBLIF);
+        else if (str == "verilog")
+            conv_value.set_value(e_circuit_format::VERILOG);
+        else if (str == "edif")
+            conv_value.set_value(e_circuit_format::EDIF);
+         else if (str == "edf")
+            conv_value.set_value(e_circuit_format::EDIF);
+        else if (str == "edn")
+            conv_value.set_value(e_circuit_format::EDIF);
         else if (str == "fpga-interchange")
             conv_value.set_value(e_circuit_format::FPGA_INTERCHANGE);
         else {
@@ -121,6 +129,10 @@ struct ParseCircuitFormat {
             conv_value.set_value("blif");
         else if (val == e_circuit_format::EBLIF)
             conv_value.set_value("eblif");
+        else if (val == e_circuit_format::VERILOG)
+            conv_value.set_value("verilog");
+        else if (val == e_circuit_format::EDIF)
+            conv_value.set_value("edif");
         else {
             VTR_ASSERT(val == e_circuit_format::FPGA_INTERCHANGE);
             conv_value.set_value("fpga-interchange");
@@ -130,7 +142,7 @@ struct ParseCircuitFormat {
     }
 
     std::vector<std::string> default_choices() {
-        return {"auto", "blif", "eblif", "fpga-interchange"};
+        return {"auto", "blif", "eblif", "verilog", "edif", "edn", "edf", "fpga-interchange"};
     }
 };
 struct ParseRoutePredictor {
@@ -397,6 +409,8 @@ struct ParsePlaceAlgorithm {
             conv_value.set_value(CRITICALITY_TIMING_PLACE);
         } else if (str == "slack_timing") {
             conv_value.set_value(SLACK_TIMING_PLACE);
+        } else if (str == "congestion_aware") {
+            conv_value.set_value(CONGESTION_AWARE_PLACE);
         } else {
             std::stringstream msg;
             msg << "Invalid conversion from '" << str << "' to e_place_algorithm (expected one of: " << argparse::join(default_choices(), ", ") << ")";
@@ -418,6 +432,8 @@ struct ParsePlaceAlgorithm {
             conv_value.set_value("bounding_box");
         } else if (val == CRITICALITY_TIMING_PLACE) {
             conv_value.set_value("criticality_timing");
+        } else if (val == CONGESTION_AWARE_PLACE) {
+            conv_value.set_value("congestion_aware");
         } else {
             VTR_ASSERT(val == SLACK_TIMING_PLACE);
             conv_value.set_value("slack_timing");
@@ -426,7 +442,7 @@ struct ParsePlaceAlgorithm {
     }
 
     std::vector<std::string> default_choices() {
-        return {"bounding_box", "criticality_timing", "slack_timing"};
+       return {"bounding_box", "criticality_timing", "slack_timing","congestion_aware"};
     }
 };
 
@@ -1408,6 +1424,10 @@ argparse::ArgumentParser create_arg_parser(std::string prog_name, t_options& arg
         .help("Show this help message then exit")
         .action(argparse::Action::HELP);
 
+    gen_grp.add_argument(args.top_mod, "--top", "-t")
+        .help("Top module name")
+        .default_value("");
+
     gen_grp.add_argument<bool, ParseOnOff>(args.show_version, "--version")
         .help("Show version information then exit")
         .action(argparse::Action::VERSION);
@@ -1865,6 +1885,16 @@ argparse::ArgumentParser create_arg_parser(std::string prog_name, t_options& arg
         .default_value("semiDirectedSwap")
         .show_in(argparse::ShowIn::HELP_ONLY);
 
+    pack_grp.add_argument<bool, ParseOnOff>(args.use_partitioning_in_pack, "--use_partitioning_in_pack")
+        .help("Whether to use partitioning in pack.")
+        .default_value("off")
+        .show_in(argparse::ShowIn::HELP_ONLY);
+
+    pack_grp.add_argument<int>(args.number_of_molecules_in_partition, "--number_of_molecules_in_partition")
+        .help("Average number of molecules in each cluster. It should be used when --use_partitioning_in_pack is on.")
+        .default_value("64")
+        .show_in(argparse::ShowIn::HELP_ONLY);
+
     auto& place_grp = parser.add_argument_group("placement options");
 
     place_grp.add_argument(args.Seed, "--seed")
@@ -1970,7 +2000,7 @@ argparse::ArgumentParser create_arg_parser(std::string prog_name, t_options& arg
             " * criticality_timing: Focuses on minimizing both the wirelength and the connection timing costs (criticality * delay).\n"
             " * slack_timing: Focuses on improving the circuit slack values to reduce critical path delay.\n")
         .default_value("criticality_timing")
-        .choices({"bounding_box", "criticality_timing", "slack_timing"})
+        .choices({"bounding_box", "criticality_timing", "slack_timing", "congestion_aware"})
         .show_in(argparse::ShowIn::HELP_ONLY);
 
     place_grp.add_argument<e_place_algorithm, ParsePlaceAlgorithm>(args.PlaceQuenchAlgorithm, "--place_quench_algorithm")
@@ -1982,7 +2012,7 @@ argparse::ArgumentParser create_arg_parser(std::string prog_name, t_options& arg
             " * criticality_timing: Focuses on minimizing both the wirelength and the connection timing costs (criticality * delay).\n"
             " * slack_timing: Focuses on improving the circuit slack values to reduce critical path delay.\n")
         .default_value("criticality_timing")
-        .choices({"bounding_box", "criticality_timing", "slack_timing"})
+        .choices({"bounding_box", "criticality_timing", "slack_timing", "congestion_aware"})
         .show_in(argparse::ShowIn::HELP_ONLY);
 
     place_grp.add_argument(args.PlaceChanWidth, "--place_chan_width")
@@ -2208,6 +2238,12 @@ argparse::ArgumentParser create_arg_parser(std::string prog_name, t_options& arg
             " 0.0 focuses completely on wirelength, 1.0 completely on timing")
         .default_value("0.5")
         .show_in(argparse::ShowIn::HELP_ONLY);
+            place_timing_grp.add_argument(args.CongestionTradeoff, "--congest_tradeoff")
+        .help(
+            "Trade-off control between routability and timing during placement."
+            " 0.0 focuses completely on routability, 1.0 completely on timing")
+        .default_value("1.0")
+        .show_in(argparse::ShowIn::HELP_ONLY);
 
     place_timing_grp.add_argument(args.RecomputeCritIter, "--recompute_crit_iter")
         .help("Controls how many temperature updates occur between timing analysis during placement")
diff --git a/vpr/src/base/read_options.h b/vpr/src/base/read_options.h
index 274ebbccf..97dba3305 100644
--- a/vpr/src/base/read_options.h
+++ b/vpr/src/base/read_options.h
@@ -64,6 +64,7 @@ struct t_options {
     argparse::ArgValue<bool> CreateEchoFile;
     argparse::ArgValue<bool> verify_file_digests;
     argparse::ArgValue<std::string> device_layout;
+    argparse::ArgValue<std::string> top_mod;
     argparse::ArgValue<float> target_device_utilization;
     argparse::ArgValue<e_constant_net_method> constant_net_method;
     argparse::ArgValue<e_clock_modeling> clock_modeling;
@@ -102,6 +103,8 @@ struct t_options {
     argparse::ArgValue<bool> use_attraction_groups;
     argparse::ArgValue<int> pack_num_moves;
     argparse::ArgValue<std::string> pack_move_type;
+    argparse::ArgValue<bool> use_partitioning_in_pack;
+    argparse::ArgValue<int> number_of_molecules_in_partition;
     /* Placement options */
     argparse::ArgValue<int> Seed;
     argparse::ArgValue<bool> ShowPlaceTiming;
@@ -125,6 +128,8 @@ struct t_options {
     argparse::ArgValue<e_place_effort_scaling> place_effort_scaling;
     argparse::ArgValue<e_place_delta_delay_algorithm> place_delta_delay_matrix_calculation_method;
     argparse::ArgValue<bool> enable_analytic_placer;
+    //Cascade_placer
+    argparse::ArgValue<bool> enable_cascade_placer;
     argparse::ArgValue<std::vector<float>> place_static_move_prob;
     argparse::ArgValue<std::vector<float>> place_static_notiming_move_prob;
     argparse::ArgValue<int> place_high_fanout_net;
@@ -160,6 +165,7 @@ struct t_options {
 
     /* Timing-driven placement options only */
     argparse::ArgValue<float> PlaceTimingTradeoff;
+    argparse::ArgValue<float> CongestionTradeoff;
     argparse::ArgValue<int> RecomputeCritIter;
     argparse::ArgValue<int> inner_loop_recompute_divider;
     argparse::ArgValue<int> quench_recompute_divider;
