#!/bin/bash

############################################################################################################################
# Description:
# This script can run the bit_sim.sh (optionally) for a testbench
# directory, run the vpr commands again but with new flags, and analyze the .route file and collects statistics.
#
# Required arguments:
# - Argument 1: pnr directory name
# - Argument 2: Testbench directory name
# - at least one of Arguments 8 and 9
# - at least one of Arguments 10-13
#
# Optional arguments (The order of optional arguments does not matter):
# - Argument 3:     "--gen_arch"                                    generates xml architecture (runs make generate_arch in pnr directory)
# - Argument 4:     "--gen_vpr_rrg"                                 generates vpr rr_graph (runs make generate_rrgraph in pnr directory)
# - Argument 5:     "--gen_stamp_rrg"                               runs "genb.py" and generates stamp rr_graph (runs make stamped_rrgraph in pnr directory)
# - Argument 6:     "--gen_bs"                                      runs "source bit_sim.sh" in the test case directory
# - Argument 7:     "--gen_bs_stamp"                                creates bit_sim_stamp.sh and runs "source bit_sim_stamp.sh" in the test case directory
# - Argument 8:     "--gen_vpr_route"                               Indicates that vpr rr_graph is used
# - Argument 9:     "--gen_stamp_route"                             Indicates that stamped rr_graph is used
# - Argument 10:    "--gen_nd_tx"                                   Collect textual node-based statistics
# - Argument 11:    "--gen_nd_vs"                                   Collect visual node-based statistics
# - Argument 12:    "--gen_eb_no"                                   Collect edge-based statistics NOT considering OPINs in the reports
# - Argument 13:    "--gen_eb_wo"                                   Collect edge-based statistics considering OPINs in the reports
# - Argument 14:    "--g_safe"                                      whether g_safe value is true or false (Default: False)
# - Argument 15:    "--run_openfpga"                                When not using Raptor flow (gen_bs_stamp), generates a .openfpga file and runs openfpga flow (Default: False)
# - Argument 16:    "--clean"                                       removes vpr/stamp directory that includes reports (Default: False)
# - Argument 17:    "--pin_util value"                              Utilization of tile pins*** (Default: not include in VPR options)
# - Argument 18:    "--partitioning_in_pack"                        Whether to use hmetis partitioning in pack. (Default: not include in VPR options)
# - Argument 19:    "--num_of_mol NUM"                              Average number of molecules in each cluster. It should be used when --partitioning_in_pack is used. (Default: 64)
# - Argument 20:    "--hmetis_path HMETIS_PATH"                     The path to the hmetis executable. (Default: ~/bin/hmetis)
# - Argument 21:    "--seed SEED"                                   Seed value for VPR run (Default: SEED=1)
# - Argument 22:    "--read_rr_graph RR_GRAPH"                      Reads rr_graph file and input it for all VPR stages. RR_GRAPH is the absolute address of the file.
# - Argument 23:    "--write_rr_graph RR_GRAPH"                     Writes rr_graph file generated by VPR. RR_GRAPH is the absolute address of the file.
# - Argument 24:    "--cp_run DIR"                                  Copies the current run outputs and results to DIR directory (absolute path).
# - Argument 25:    "--clb_packing OPTION"                          clb_packing <directive> in packing_options OPTION --> Performance optimization flags (auto, dense, timing_driven)
# - Argument 26:    "--gen_place_const"                             Generates placement constraint file and use "free" mode for IO pin assignments
# - Argument 27:    "--pnr_options OPT(s) --pnr_options_end"        All pnr_options that Raptor can support. 
# - Argument 28:    "--packing_options OPT(s) --packing_options_end"All packing_options that Raptor can support.
# - Argument 29:    "--work_dir DIR"                                overrides the default path for working directory
# - Argument 30:    "--restart_route"                               Runs Raptor again but starts from routing stage until the end.
# - Argument 31:    "--vpr_based_stamp_run"                               Runs Raptor again but starts from routing stage until the end. Also use _golden directory as the base directory.

# Argument 27 and Argument 28 should be used instead of Argument 17-23
#
# Examples:
# ./collect_stats.sh FPGA10x8_gemini_compact_latch_pnr   add_1bit                --gen_bs --gen_vpr_route --gen_nd_tx --gen_nd_vs --gen_eb_no --gen_eb_wo
# ./collect_stats.sh FPGA10x8_gemini_compact_stamp_pnr   add_1bit                --gen_stamp_rrg --gen_stamp_route --gen_nd_tx --gen_nd_vs --gen_eb_no --gen_eb_wo
#
#
# Note: if gen_bs, gen_arch, gen_vpr_rrg, or gen_stamp_rrg are skipped, it means that they are
# already generated. without the results of them statistics cannot be generated.
#
# *** This refers to "--target_ext_pin_util TARGET_EXT_PIN_UTIL" option in VPR command. To see the details of this option
# run vpr --help to see the explanation. It can get Single Value (e.g. '0.7'), Double Value (e.g. '0.7,0.8'), and
# Block Value (e.g. 'clb:0.7', 'clb:0.7,0.8'). If you do not include any value, VPR sets it automatically. 
############################################################################################################################


#WORKING_DIR=$(pwd)
#archbench_dir="$WORKING_DIR/.."
# scripts_dir=$archbench_dir/openfpga-pd-castor-rs/k6n8_TSMC16nm_7.5T/CommonFiles/task/automation/evalroute

# Set default values for optional arguments
gen_arch="no"
gen_vpr_rrg="no"
gen_stamp_rrg="no"
gen_bs="no"
gen_bs_stamp="no"
gen_vpr_route="no"
gen_stamp_route="no"
gen_nd_tx="no"
gen_nd_vs="no"
gen_eb_no="no"
gen_eb_wo="no"
g_safe="false"
run_openfpga="no"
clean="no"
pin_util=""
partitioning_in_pack=""
num_of_mol=""
hmetis_path=""
seed=""
read_rr_graph=""
write_rr_graph=""
cp_run=""
clb_packing=""
gen_place_const="no"
pnr_options=""
packing_options=""
pnr_options_begin=false
packing_options_begin=false
work_dir=""
restart_route="no"
vpr_based_stamp_run="no"


if [ $# -lt 4 ]; then
  echo "Error: This script requires at least 4 arguments."
  echo "Usage: $0 <pnr_directory> <testbench_dir_name> [two of other options]"
  exit 1
fi

# Get the length of the input argument list
num_args=${#}

# Loop through all the input arguments
for ((i=1; i<=num_args; i++))
do
    # If it's the first argument, assign it to testbench top directory name
    if [ $i -eq 1 ]; then
        PNR_DIR=${!i}
    elif [ $i -eq 2 ]; then
        DESIGN_DIR_NAME=${!i}
    else
        # Check the value of the argument and assign to different variables
        if [ $pnr_options_begin == "true" ]; then
            if [ ${!i} == "--pnr_options_end" ]; then
                pnr_options_begin="false"
            else
                pnr_options="$pnr_options ${!i}"
            fi
        elif [ $packing_options_begin == "true" ]; then
            if [ ${!i} == "--packing_options_end" ]; then
                packing_options_begin="false"
            else
                packing_options="$packing_options ${!i}"
            fi
        elif [ ${!i} == "--gen_arch" ]; then
            gen_arch="yes"
        elif [ ${!i} == "--gen_vpr_rrg" ]; then
            gen_vpr_rrg="yes"
        elif [ ${!i} == "--gen_stamp_rrg" ]; then
            gen_stamp_rrg="yes"
        elif [ ${!i} == "--gen_bs" ]; then
            gen_bs="yes"
        elif [ ${!i} == "--gen_bs_stamp" ]; then
            gen_bs_stamp="yes"
        elif [ ${!i} == "--gen_vpr_route" ]; then
            gen_vpr_route="yes"
        elif [ ${!i} == "--gen_stamp_route" ]; then
            gen_stamp_route="yes"
        elif [ ${!i} == "--gen_nd_tx" ]; then
            gen_nd_tx="yes"
        elif [ ${!i} == "--gen_nd_vs" ]; then
            gen_nd_vs="yes"
        elif [ ${!i} == "--gen_eb_no" ]; then
            gen_eb_no="yes"
        elif [ ${!i} == "--gen_eb_wo" ]; then
            gen_eb_wo="yes"
        elif [ ${!i} == "--g_safe" ]; then
            g_safe="true"
        elif [ ${!i} == "--run_openfpga" ]; then
            run_openfpga="yes"
        elif [ ${!i} == "--clean" ]; then
            clean="yes"
        elif [ ${!i} == "--pin_util" ]; then
            ((i++))
            pin_util="--target_ext_pin_util ${!i}"
        elif [ ${!i} == "--partitioning_in_pack" ]; then
            partitioning_in_pack="--use_partitioning_in_pack on"
        elif [ ${!i} == "--num_of_mol" ]; then
            ((i++))
            num_of_mol="--number_of_molecules_in_partition ${!i}"
        elif [ ${!i} == "--hmetis_path" ]; then
            ((i++))
            hmetis_path="--hmetis_path ${!i}"
        elif [ ${!i} == "--seed" ]; then
            ((i++))
            seed="--seed ${!i}"
        elif [ ${!i} == "--read_rr_graph" ]; then
            ((i++))
            read_rr_graph="--read_rr_graph ${!i}"
        elif [ ${!i} == "--write_rr_graph" ]; then
            ((i++))
            write_rr_graph="--write_rr_graph ${!i}"
        elif [ ${!i} == "--cp_run" ]; then
            ((i++))
            cp_run="${!i}"
        elif [ ${!i} == "--clb_packing" ]; then
            ((i++))
            clb_packing="-clb_packing ${!i}"
        elif [ ${!i} == "--pnr_options" ]; then
            ((i++))
            pnr_options="${!i}"
            pnr_options_begin="true"
        elif [ ${!i} == "--packing_options" ]; then
            ((i++))
            packing_options="${!i}"
            packing_options_begin="true"
        elif [ ${!i} == "--gen_place_const" ]; then
            gen_place_const="yes"
        elif [ ${!i} == "--work_dir" ]; then
            ((i++))
            work_dir="${!i}"
        elif [ ${!i} == "--restart_route" ]; then
            restart_route="yes"
        elif [ ${!i} == "--vpr_based_stamp_run" ]; then
            vpr_based_stamp_run="yes"
        fi
    fi
done

# Unset $1 and $2 so that bit_sim.sh cannot see their values
set -- ""

ARCHBENCH=`git rev-parse --show-toplevel`
if [ -f $ARCHBENCH/openfpga-pd-castor-rs/k6n8_TSMC16nm_7.5T/CommonFiles/task/automation/evalroute/node_statistics.py ]; then
    echo "No need to update submodule"
else
    echo -e "openfpga-pd-castor-rs is not initialized. Please initilize it using below command:\ncd $ARCHBENCH/openfpga-pd-castor-rs && git submodule update --init && git checkout main && git pull origin main && git pull origin --tags"
    exit 1
fi
OPENFPGA_PD_CASTOR_RS=$ARCHBENCH/openfpga-pd-castor-rs
EVALROUTE=$OPENFPGA_PD_CASTOR_RS/k6n8_TSMC16nm_7.5T/CommonFiles/task/automation/evalroute
TESTCASES_DIR=$ARCHBENCH/Testcases
LOCAL_RAPTOR_PATH=/nfs_project/castor/mabbaszadeh/workarea/Raptor # TODO: once stamp routing works fine, no need to use this path
FLOW_INPUTS=$OPENFPGA_PD_CASTOR_RS/k6n8_TSMC16nm_7.5T/$PNR_DIR/fabric_task/flow_inputs

if [ -z "$work_dir" ]; then
    WORKING_DIR=$TESTCASES_DIR/$DESIGN_DIR_NAME
else
    WORKING_DIR=$work_dir
fi

LATEST_MODULE="fpga_tools/raptor/latest"
VPR_BIN_DIR="$LOCAL_RAPTOR_PATH/build/bin/vpr" # TODO: once stamp routing works fine, change to "vpr" rather than "$LOCAL_RAPTOR_PATH/build/bin/vpr"
OPENFPGA_BIN_DIR="$LOCAL_RAPTOR_PATH/build/bin/openfpga" # TODO: once stamp routing works fine, change to "openfpga" rather than "$LOCAL_RAPTOR_PATH/build/bin/openfpga"


# Set the output and error log file paths
[ -d $WORKING_DIR/route_stats ] || mkdir -p $WORKING_DIR/route_stats

log_file="$WORKING_DIR/route_stats/collect_stats.log"
if [ "$gen_vpr_route" == "yes" ]; then
    log_file="$WORKING_DIR/route_stats/collect_stats_vpr.log"
elif [ "$gen_stamp_route" == "yes" ]; then
    if [ "$g_safe" == "true" ]; then
        log_file="$WORKING_DIR/route_stats/collect_stats_stamp_gsafe_true.log"
    elif [ "$g_safe" == "false" ]; then
        log_file="$WORKING_DIR/route_stats/collect_stats_stamp_gsafe_false.log"
    fi
fi

# Redirect standard outputs and standard errors to the log file
exec > >(tee "$log_file") 2>&1

echo "ARCHBENCH: $ARCHBENCH"
echo "OPENFPGA_PD_CASTOR_RS: $OPENFPGA_PD_CASTOR_RS"
echo "EVALROUTE: $EVALROUTE"
echo "TESTCASES_DIR: $TESTCASES_DIR"
echo "LOCAL_RAPTOR_PATH: $LOCAL_RAPTOR_PATH"
echo "WORKING_DIR: $WORKING_DIR"
echo -e "\n\n\n"

# generate vpr.xml file for the specified pnr directory
if [ "$gen_arch" == "yes" ]; then
    cd $OPENFPGA_PD_CASTOR_RS/k6n8_TSMC16nm_7.5T/$PNR_DIR
    echo "make clean ..."
    make clean
    echo "make generate_arch ..."
    make generate_arch STAMPER_OPT="-gt" 2>&1 | tee generate_arch.log
fi
vpr_xml=$FLOW_INPUTS/k6n8_vpr_annotated.xml
echo "vpr_xml address: $vpr_xml"
echo -e "\n\n\n"

# generate vpr rr graph file for the specified pnr directory
if [ "$gen_vpr_rrg" == "yes" ]; then
    cd $OPENFPGA_PD_CASTOR_RS/k6n8_TSMC16nm_7.5T/$PNR_DIR
    echo "make clean ..."
    make clean
    echo "make generate_rrgraph ..."
    make generate_rrgraph STAMPER_OPT="-gt" 2>&1 | tee generate_rrgraph.log
fi
vpr_rr_graph=$FLOW_INPUTS/rr_graph.xml
echo "vpr_rr_graph address: $vpr_rr_graph"
echo -e "\n\n\n"

stamp_rr_graph=$FLOW_INPUTS/rr_graph.stamped.xml

# generate stamp rr graph file for the specified pnr directory
if [ "$gen_stamp_rrg" == "yes" ]; then
    
    echo "generate mux patter with g_safe = $g_safe ..."
    file_path="$OPENFPGA_PD_CASTOR_RS/k6n8_TSMC16nm_7.5T/CommonFiles/task/arch/rr_graph_builder/genb.py"
    pattern="g_safe ="
        if [ "$g_safe" == "true" ]; then
            new_line="g_safe = True"
        else
            new_line="g_safe = False"
        fi
    sed -i "s/${pattern}.*/${new_line}/" "${file_path}"
    cd $OPENFPGA_PD_CASTOR_RS/k6n8_TSMC16nm_7.5T/CommonFiles/task/arch/rr_graph_builder
    (./genb.py)

    cd $OPENFPGA_PD_CASTOR_RS/k6n8_TSMC16nm_7.5T/$PNR_DIR
    echo "make clean ..."
    make clean
    echo "make stamped_rrgraph ..."
    if [ "$g_safe" == "true" ]; then
        make stamped_rrgraph STAMPER_OPT="-gt" 2>&1 | tee stamped_rrgraph_gsafe_true.log
        cp ./fabric_task/flow_inputs/rr_graph.stamped.xml ./fabric_task/flow_inputs/rr_graph.stamped_gsafe_true.xml
        stamp_rr_graph=$FLOW_INPUTS/rr_graph.stamped_gsafe_true.xml
    else
        make stamped_rrgraph STAMPER_OPT="-gt" 2>&1 | tee stamped_rrgraph_gsafe_false.log
        cp ./fabric_task/flow_inputs/rr_graph.stamped.xml ./fabric_task/flow_inputs/rr_graph.stamped_gsafe_false.xml
        stamp_rr_graph=$FLOW_INPUTS/rr_graph.stamped_gsafe_false.xml
    fi
fi

if [ "$gen_stamp_route" == "yes" ]; then
    echo "stamp_rr_graph address: $stamp_rr_graph"
    echo -e "\n\n\n"
fi


# run bit_sim.sh in the testcase directory
if [ "$gen_bs" == "yes" ]; then
    cd $WORKING_DIR

    bit_sim_content=$(<bit_sim.sh)

    fix_clusters=""
    # Create and add placement constraint file to raptor.tcl
    if [ "$gen_place_const" == "yes" ]; then
        
        # make sure pin_loc_assign_method free is not commented out
        search_line="echo \"pin_loc_assign_method free\">>raptor.tcl"
        new_line="echo \"pin_loc_assign_method free\">>raptor.tcl"
        if [[ $bit_sim_content =~ "$search_line" ]]; then
            bit_sim_content=$(echo "$bit_sim_content" | sed "/$search_line/c$new_line")
        else
            search_line="echo \"packing\">>raptor.tcl"
            if [[ $bit_sim_content =~ $search_line ]]; then
                bit_sim_content="${bit_sim_content//$search_line/$new_line\n$search_line}"
            fi
        fi

        # find the size of device
        target_line='device='
        device_name=""
        if [[ $bit_sim_content =~ $target_line([^\ ]+) ]]; then
            device_name=${BASH_REMATCH[1]}  # Get the first capture group
        else
            echo "device_name not found in the content"
        fi
        # dimensions=$(echo "$device_name" | awk -F_ '{print $NF}')
        # max_x=$(echo "$dimensions" | cut -dx -f1)
        # max_y=$(echo "$dimensions" | cut -dx -f2)
        # echo "Max X: $max_x"
        # echo "Max Y: $max_y"
        
        # determine the size of device
        max_x=""
        max_y=""
        if [[ $device_name == *"104x68"* ]]; then
            max_x="104"
            max_y="68" 
        elif [[ $device_name == *"62x44"* ]]; then
            max_x="62"
            max_y="44"
        elif [[ $device_name == *"10x8"* ]]; then
            max_x="10"
            max_y="8"
        else
            max_x="-1"
            max_y="-1"
        fi

        # add python script and run it if it is not already there
        search_line="set python_script"
        if [[ $bit_sim_content =~ "$search_line" ]]; then
            echo "python script for placement constraint already exists"
        else
            echo "creating python script for placement constraint the first time"
            search_line="echo \"packing\">>raptor.tcl"

            ports_file="$WORKING_DIR/*_golden/"
            new_line_1="echo \"set python_script \\\"$EVALROUTE/gen_constraints.py\\\" \">>raptor.tcl"
            new_line_2="echo \"set input_file \\\"$ports_file\\\" \">>raptor.tcl"
            new_line_3="echo \"set output_file \\\"$WORKING_DIR/pin_loc.place\\\" \">>raptor.tcl"
            #new_line_4='echo "exec python3 \$python_script --input_file \$input_file --output_file \$output_file --max_x $max_x --max_y $max_y" >>raptor.tcl'
            new_line_4="echo \"set output [exec python3 \\\$python_script --input_file \\\$input_file --output_file \\\$output_file --max_x $max_x --max_y $max_y]\" >>raptor.tcl"
            new_line_5="echo \"puts \\\"Python output: \\\$output\\\" \">>raptor.tcl"
            echo "writing python script for the first time"
            if [[ $bit_sim_content =~ $search_line ]]; then
                bit_sim_content="${bit_sim_content//$search_line/$search_line\n$new_line_1\n$new_line_2\n$new_line_3\n$new_line_4\n$new_line_5}"
            fi
        fi
        fix_clusters="--fix_clusters \\\\\$output_file"
    else
        # make sure pin_loc_assign_method free is commented out
        search_line="echo \"pin_loc_assign_method free\">>raptor.tcl"
        new_line="# echo \"pin_loc_assign_method free\">>raptor.tcl"
        if [[ $bit_sim_content =~ "$search_line" ]]; then
            search_line1="# echo \"pin_loc_assign_method free\">>raptor.tcl"
            search_line2="#echo \"pin_loc_assign_method free\">>raptor.tcl"
            if [[ $bit_sim_content =~ "$search_line1" ]] || [[ $bit_sim_content =~ "$search_line2" ]]; then
                echo "pin_loc_assign_method free already commented out"
            else
                bit_sim_content=$(echo "$bit_sim_content" | sed "/$search_line/c$new_line")
            fi
        fi
    fi

    # Add two pnr_options to raptor.tcl

    # 1. before packing
    new_line="echo \"pnr_options $pnr_options --generate_rr_node_overuse_report on\">>raptor.tcl"
    
    if echo "$bit_sim_content" | grep -q -P 'echo "pnr_options (?!.*--fix_clusters)'; then
        echo "1st pnr_options already exists"
        line_number=$(echo "$bit_sim_content" | grep -n -P 'echo "pnr_options(?!.*--fix_clusters)' | cut -d':' -f1)
        if [ -n "$line_number" ]; then
            echo "overriding 1st pnr_options..."
            modified_content=$(echo "$bit_sim_content" | awk -v line="$line_number" -v new_line="$new_line" 'NR == line {print new_line; next} {print}')
        fi
    else
        echo "writing 1st pnr_options for the first time"
        search_line="echo \"packing\">>raptor.tcl"
        if [[ $bit_sim_content =~ $search_line ]]; then
            modified_content="${bit_sim_content//$search_line/$new_line\n$search_line}"
        else
            modified_content=$bit_sim_content
        fi
    fi


    if [ -z "$fix_clusters" ]; then
        echo "no need to add 2nd pnr_options command before placement (we don't have fix_clusters command)"
    else
        # 2. before placement
        new_line="echo \"pnr_options $pnr_options $fix_clusters --generate_rr_node_overuse_report on\">>raptor.tcl"
        
        if echo "$bit_sim_content" | grep -q -P 'echo "pnr_options .*--fix_clusters'; then
            echo "2nd pnr_options already exists"
            line_number=$(echo "$modified_content" | grep -n -P 'echo "pnr_options .* --fix_clusters' | cut -d':' -f1)
            if [ -n "$line_number" ]; then
                echo "overriding 2nd pnr_options..."
                modified_content=$(echo "$modified_content" | awk -v line="$line_number" -v new_line="$new_line" 'NR == line {print new_line; next} {print}')
            fi
        else
            echo "writing 2nd pnr_options for the first time"
            search_line1="echo \"global_placement\">>raptor.tcl"
            search_line2="echo \"place\">>raptor.tcl"
            if [[ $modified_content =~ $search_line1 ]]; then
                modified_content="${modified_content//$search_line1/$new_line\n$search_line1}"
            elif [[ $modified_content =~ $search_line2 ]]; then
                modified_content="${modified_content//$search_line2/$new_line\n$search_line2}"
            else
                modified_content=$modified_content
            fi
        fi
    fi

    # Add packing_options to raptor.tcl
    # if [ -n "$clb_packing" ]; then
    if [ -n "$packing_options" ]; then
        search_line="echo \"packing_options "
        # new_line="echo \"packing_options $clb_packing\">>raptor.tcl"
        new_line="echo \"packing_options $packing_options\">>raptor.tcl"
        if [[ $modified_content =~ "$search_line" ]]; then
            echo "packing_options already exists"
            modified_content=$(echo "$modified_content" | sed "/$search_line/c$new_line")
        else
            echo "writing packing_options for the first time"
            search_line="echo \"packing\">>raptor.tcl"
            if [[ $modified_content =~ $search_line ]]; then
                modified_content="${modified_content//$search_line/$new_line\n$search_line}"
            fi
        fi
    else
        search_line="echo \"packing_options "
        new_line="echo \"packing_options\">>raptor.tcl"
        if [[ $modified_content =~ "$search_line" ]]; then
            echo "packing_options already exists - must be removed"
            modified_content=$(echo "$modified_content" | sed "/$search_line/c$new_line")
        fi
    fi
    
    echo -e "$modified_content" > bit_sim_vpr.sh

    #Make bit_sim_stamp.sh executable
    chmod +x bit_sim_vpr.sh
    
    eval "module load $LATEST_MODULE"
    echo -e "source bit_sim_vpr.sh...\n"
    source bit_sim_vpr.sh 2>&1 | tee bit_sim_vpr.log
    echo -e "\n\n\n"
fi

# create an run bit_sim_stamp.sh in the testcase directory
if [ "$gen_bs_stamp" == "yes" ]; then
    cd $WORKING_DIR
    echo -e "creating bit_sim_stamp.sh...\n"

    [ -f "bit_sim_stamp.sh" ] && rm -fr "bit_sim_stamp.sh"
    
    # Read the content of bit_sim.sh into a variable
    bit_sim_sh_content=$(<bit_sim.sh)

    # Modify raptor bin address # TODO: To be removed after pushing my changes in Raptor Backend repo
    # modified_line="fixed_sim_path=\`which /nfs_project/castor/mabbaszadeh/workarea/Raptor/build/bin/raptor | xargs dirname\`"
    # modified_content=${bit_sim_sh_content//fixed_sim_path=\`which raptor | xargs dirname\`/$modified_line}
    # string="-v raptor"
    # new_string="-v /nfs_project/castor/mabbaszadeh/workarea/Raptor/build/bin/raptor"
    # modified_content=${modified_content//$string/$new_string}
    # string="which raptor"
    # new_string="which /nfs_project/castor/mabbaszadeh/workarea/Raptor/build/bin/raptor"
    # modified_content=${modified_content//$string/$new_string}
    # modified_line="/nfs_project/castor/mabbaszadeh/workarea/Raptor/build/bin/raptor --batch --script raptor.tcl"
    # modified_content=${modified_content//"raptor --batch --script raptor.tcl"/"$modified_line"}
    # modified_line="/nfs_project/castor/mabbaszadeh/workarea/Raptor/build/bin/raptor --version>>raptor.log"
    # modified_content=${modified_content//"raptor --version>>raptor.log"/"$modified_line"}
    
    # Temporarly comment out running parser.py because of high run-time ( thousands of Warnings in VPR run of stamper --> taking a long time to parse)
    # TODO: to be removed once the warnings disappear
    string="python3 ../../scripts/parser.py"
    new_string="# python3 ../../scripts/parser.py"
    modified_content=${bit_sim_sh_content//$string/$new_string}

    # Modify working directory
    modified_content=${modified_content//"_golden"/"_stamp"}
    
    # Modify variable names
    modified_content=${modified_content//"vpr_file_path"/"stamped_vpr_file_path"}
    modified_content=${modified_content//"openfpga_file_path"/"stamped_openfpga_file_path"}
    modified_content=${modified_content//"bitstream_setting_path"/"stamped_bitstream_setting_path"}
    modified_content=${modified_content//"repack_design_constraint_path"/"stamped_repack_design_constraint_path"}
    modified_content=${modified_content//"fabric_key_path"/"stamped_fabric_key_path"}
    modified_content=${modified_content//"\$set_channel_width"/"\$stamped_set_channel_width"}

    fix_clusters=""
    # Create and add placement constraint file to raptor.tcl
    if [ "$gen_place_const" == "yes" ]; then
        
        # make sure pin_loc_assign_method free is not commented out
        search_line="echo \"pin_loc_assign_method free\">>raptor.tcl"
        new_line="echo \"pin_loc_assign_method free\">>raptor.tcl"
        if [[ $modified_content =~ "$search_line" ]]; then
            modified_content=$(echo "$modified_content" | sed "/$search_line/c$new_line")
        else
            search_line="echo \"packing\">>raptor.tcl"
            if [[ $modified_content =~ $search_line ]]; then
                modified_content="${modified_content//$search_line/$new_line\n$search_line}"
            fi
        fi

        # find the size of device
        target_line='device='
        device_name=""
        if [[ $modified_content =~ $target_line([^\ ]+) ]]; then
            device_name=${BASH_REMATCH[1]}  # Get the first capture group
        else
            echo "device_name not found in the content"
        fi
        # dimensions=$(echo "$device_name" | awk -F_ '{print $NF}')
        # max_x=$(echo "$dimensions" | cut -dx -f1)
        # max_y=$(echo "$dimensions" | cut -dx -f2)
        # echo "Max X: $max_x"
        # echo "Max Y: $max_y"
        
        # determine the size of device
        max_x=""
        max_y=""
        if [[ $device_name == *"104x68"* ]]; then
            max_x="104"
            max_y="68" 
        elif [[ $device_name == *"62x44"* ]]; then
            max_x="62"
            max_y="44"
        elif [[ $device_name == *"10x8"* ]]; then
            max_x="10"
            max_y="8"
        else
            max_x="-1"
            max_y="-1"
        fi

        # add python script and run it if it is not already there
        search_line="set python_script"
        if [[ $modified_content =~ "$search_line" ]]; then
            echo "python script for placement constraint already exists"
        else
            echo "creating python script for placement constraint the first time"
            search_line="echo \"packing\">>raptor.tcl"

            ports_file="$WORKING_DIR/*_stamp/"
            new_line_1="echo \"set python_script \\\"$EVALROUTE/gen_constraints.py\\\" \">>raptor.tcl"
            new_line_2="echo \"set input_file \\\"$ports_file\\\" \">>raptor.tcl"
            new_line_3="echo \"set output_file \\\"$WORKING_DIR/pin_loc.place\\\" \">>raptor.tcl"
            new_line_4="echo \"set output [exec python3 \\\$python_script --input_file \\\$input_file --output_file \\\$output_file --max_x $max_x --max_y $max_y]\" >>raptor.tcl"
            new_line_5="echo \"puts \\\"Python output: \\\$output\\\" \">>raptor.tcl"
            echo "writing python script for the first time"
            if [[ $modified_content =~ $search_line ]]; then
                modified_content="${modified_content//$search_line/$search_line\n$new_line_1\n$new_line_2\n$new_line_3\n$new_line_4\n$new_line_5}"
            fi
        fi
        fix_clusters="--fix_clusters \\\\\$output_file"
    
    else
        # make sure pin_loc_assign_method free is commented out
        search_line="echo \"pin_loc_assign_method free\">>raptor.tcl"
        new_line="# echo \"pin_loc_assign_method free\">>raptor.tcl"
        if [[ $modified_content =~ "$search_line" ]]; then
            search_line1="# echo \"pin_loc_assign_method free\">>raptor.tcl"
            search_line2="#echo \"pin_loc_assign_method free\">>raptor.tcl"
            if [[ $modified_content =~ "$search_line1" ]] || [[ $modified_content =~ "$search_line2" ]]; then
                echo "pin_loc_assign_method free already commented out"
            else
                modified_content=$(echo "$modified_content" | sed "/$search_line/c$new_line")
            fi
        fi
    fi

    # Add two pnr_options to raptor.tcl
    
    if [[ $pnr_options == *"--read_rr_graph"* ]]; then
        new_line="echo \"pnr_options $pnr_options --generate_rr_node_overuse_report on\">>raptor.tcl"
    else
        new_line="echo \"pnr_options $pnr_options --read_rr_graph \$stamped_rr_graph --generate_rr_node_overuse_report on\">>raptor.tcl"
    fi

    if echo "$modified_content" | grep -q -P 'echo "pnr_options (?!.*--fix_clusters)'; then
        echo "1st pnr_options already exists"
        line_number=$(echo "$modified_content" | grep -n -P 'echo "pnr_options(?!.*--fix_clusters)' | cut -d':' -f1)
        if [ -n "$line_number" ]; then
            echo "overriding 1st pnr_options..."
            modified_content=$(echo "$modified_content" | awk -v line="$line_number" -v new_line="$new_line" 'NR == line {print new_line; next} {print}')
        fi
    else
        echo "writing 1st pnr_options for the first time"
        search_line="echo \"packing\">>raptor.tcl"
        if [[ $modified_content =~ $search_line ]]; then
            modified_content="${modified_content//$search_line/$new_line\n$search_line}"
        else
            modified_content=$modified_content
        fi
    fi

    if [ -z "$fix_clusters" ]; then
        echo "no need to add 2nd pnr_options command before placement (we don't have fix_clusters command)"
    else

        if [[ $pnr_options == *"--read_rr_graph"* ]]; then
            new_line="echo \"pnr_options $pnr_options $fix_clusters --generate_rr_node_overuse_report on\">>raptor.tcl"
        else
            new_line="echo \"pnr_options $pnr_options $fix_clusters --read_rr_graph \$stamped_rr_graph --generate_rr_node_overuse_report on\">>raptor.tcl"
        fi

        if echo "$modified_content" | grep -q -P 'echo "pnr_options .*--fix_clusters'; then
            echo "2nd pnr_options already exists"
            line_number=$(echo "$modified_content" | grep -n -P 'echo "pnr_options .* --fix_clusters' | cut -d':' -f1)
            if [ -n "$line_number" ]; then
                echo "overriding 2nd pnr_options..."
                modified_content=$(echo "$modified_content" | awk -v line="$line_number" -v new_line="$new_line" 'NR == line {print new_line; next} {print}')
            fi
        else
            echo "writing 2nd pnr_options for the first time"
            search_line1="echo \"global_placement\">>raptor.tcl"
            search_line2="echo \"place\">>raptor.tcl"
            if [[ $modified_content =~ $search_line1 ]]; then
                modified_content="${modified_content//$search_line1/$new_line\n$search_line1}"
            elif [[ $modified_content =~ $search_line2 ]]; then
                modified_content="${modified_content//$search_line2/$new_line\n$search_line2}"
            else
                modified_content=$modified_content
            fi
        fi
    fi

    # Add packing_options to raptor.tcl
    if [ -n "$packing_options" ]; then
        search_line="echo \"packing_options "
        new_line="echo \"packing_options $packing_options\">>raptor.tcl"
        if [[ $modified_content =~ "$search_line" ]]; then
            echo "packing_options already exists"
            modified_content=$(echo "$modified_content" | sed "/$search_line/c$new_line")
        else
            echo "writing packing_options for the first time"
            search_line="echo \"packing\">>raptor.tcl"
            if [[ $modified_content =~ $search_line ]]; then
                modified_content="${modified_content//$search_line/$new_line\n$search_line}"
            fi
        fi
    else
        search_line="echo \"packing_options "
        new_line="echo \"packing_options\">>raptor.tcl"
        if [[ $modified_content =~ "$search_line" ]]; then
            echo "packing_options already exists - must be removed"
            modified_content=$(echo "$modified_content" | sed "/$search_line/c$new_line")
        fi
    fi

    if [ "$vpr_based_stamp_run" == "yes" ] && [ -n "$cp_run" ]; then
        modified_content=$(echo "$modified_content" | sed -e '/^xml_version/,$ s/^/# /')
    fi
    echo -e "$modified_content" > bit_sim_stamp.sh

    #Make bit_sim_stamp.sh executable
    chmod +x bit_sim_stamp.sh
    
    eval "module load $LATEST_MODULE"
    echo -e "source bit_sim_stamp.sh...\n"
    source bit_sim_stamp.sh 2>&1 | tee bit_sim_stamp.log
    echo -e "\n\n\n"
fi

# resume from routing stage
if [ "$restart_route" == "yes" ]; then

    echo "restarting from routing stage ..."

    if [ "$gen_vpr_route" == "yes" ]; then
        cd $WORKING_DIR/*_golden
    elif [ "$gen_stamp_route" == "yes" ]; then
        cd $WORKING_DIR/*_stamp
    fi

    
    if [ "$vpr_based_stamp_run" == "yes" ]; then

        # Search for .net file and store its absolute path
        stamp_net_addr=$(find . -type f -name "*_post_synth.net" -print -quit)
        # Check if the file was found
        if [ -n "$stamp_net_addr" ]; then
            echo "Found Stamp _post_synth.net file to modify vpr.xml SHA256: $stamp_net_addr"
        else
            echo "ERROR: No Stamp _post_synth.net file found to modify vpr.xml SHA256. Looking for .net file..."
            stamp_net_addr=$(find . -type f -name "*.net" -print -quit)
            if [ -n "$stamp_net_addr" ]; then
                echo "Found Stamp .net file to modify vpr.xml SHA256: $stamp_net_addr"
            else
                echo "ERROR: No Stamp .net file found to modify vpr.xml SHA256."
            fi
        fi
        

        # Calculate the SHA-256 hash of the file
        new_sha256=$(sha256sum "$vpr_xml" | awk '{print $1}')

        # Use sed to replace the old SHA256 value with the new one
        sed -i "s/architecture_id=\"SHA256:[0-9a-f]\{64\}\"/architecture_id=\"SHA256:$new_sha256\"/g" "$stamp_net_addr"
        

        # Search for .place file and store its absolute path
        stamp_place_addr=$(find . -type f -name "*_post_synth.place" -print -quit)
        # Check if the file was found
        if [ -n "$stamp_place_addr" ]; then
            echo "Found Stamp _post_synth.place file to modify .net SHA256: $stamp_place_addr"
        else
            echo "ERROR: No Stamp _post_synth.place file to modify .net SHA256 found. Looking for .place file..."
            stamp_place_addr=$(find . -type f -name "*.place" -print -quit)
            if [ -n "$stamp_place_addr" ]; then
                echo "Found Stamp .place file to modify .net SHA256: $stamp_place_addr"
            else
                echo "ERROR: No Stamp .place file to modify .net SHA256 found."
            fi
        fi

        # Calculate the SHA-256 hash of the file
        new_sha256=$(sha256sum "$stamp_net_addr" | awk '{print $1}')

        # Use sed to replace the old SHA256 value with the new one
        sed -i "s/Netlist_ID: SHA256:[0-9a-f]\{64\}/Netlist_ID: SHA256:$new_sha256/g" "$stamp_place_addr"
        
    fi
    
    
    raptor_tcl_content=$(<raptor.tcl)


    analyze_command="# "
    synthesize_command="# "
    packing_command=""
    global_placement_command=""
    place_command=""
    route_command=""
    sta_command=""
    power_command=""
    bitstream_command=""
    python_command="# "
    puts_command="# "
    
    echo "removing sub-directories from the run directory ..."
    # find . -type d -name analysis -exec rm -r {} +
    # find . -type d -name synthesize -exec rm -r {} +
    # find . -type d -name packing -exec rm -r {} +
    # find . -type d -name placement -exec rm -r {} +
    find . -type d -name routing -exec rm -r {} +
    find . -type d -name timing_analysis -exec rm -r {} +
    find . -type d -name power_analysis -exec rm -r {} +
    find . -type d -name bitstream -exec rm -r {} +


    echo "modifying raptor.tcl ..."
    search_line="analyze"
    raptor_tcl_content=$(echo "$raptor_tcl_content" | sed -E "/$search_line/s/^(# )?$search_line/$analyze_command$search_line/")

    search_line="synthesize"
    raptor_tcl_content=$(echo "$raptor_tcl_content" | sed -E "/$search_line/s/^(# )?$search_line/$synthesize_command$search_line/")

    search_line="packing"
    raptor_tcl_content=$(echo "$raptor_tcl_content" | sed -E "/$search_line/s/^(# )?$search_line/$packing_command$search_line/")

    search_line="global_placement"
    raptor_tcl_content=$(echo "$raptor_tcl_content" | sed -E "/$search_line/s/^(# )?$search_line/$global_placement_command$search_line/")

    search_line="place"
    raptor_tcl_content=$(echo "$raptor_tcl_content" | sed -E "/$search_line/s/^(# )?$search_line/$place_command$search_line/")

    search_line="route"
    raptor_tcl_content=$(echo "$raptor_tcl_content" | sed -E "/$search_line/s/^(# )?$search_line/$route_command$search_line/")

    search_line="sta"
    raptor_tcl_content=$(echo "$raptor_tcl_content" | sed -E "/$search_line/s/^(# )?$search_line/$sta_command$search_line/")

    search_line="power"
    raptor_tcl_content=$(echo "$raptor_tcl_content" | sed -E "/$search_line/s/^(# )?$search_line/$power_command$search_line/")

    search_line="bitstream"
    raptor_tcl_content=$(echo "$raptor_tcl_content" | sed -E "/$search_line/s/^(# )?$search_line/$bitstream_command$search_line/")

    search_line="set output "
    raptor_tcl_content=$(echo "$raptor_tcl_content" | sed -E "/$search_line/s/^(# )?$search_line/$python_command$search_line/")

    search_line="puts"
    raptor_tcl_content=$(echo "$raptor_tcl_content" | sed -E "/$search_line/s/^(# )?$search_line/$puts_command$search_line/")

    echo -e "$raptor_tcl_content" > raptor.tcl
    
    echo "module load $LATEST_MODULE ..."
    module load $LATEST_MODULE

    echo "running raptor.tcl ..."
    start_raptor=`date +%s`
    raptor --batch --script raptor.tcl
    end_raptor=`date +%s`
    runtime_raptor=$((end_raptor-start_raptor))
    echo -e "Total raptor RunTime: $runtime_raptor sec"
fi

# pinmap file is generated as part of generating stamp rr_graph
pinmap_file="$EVALROUTE/rr_graph.pinmap"
echo "pinmap file address: $pinmap_file"



# finding the name of the design and go to the appropriate directory to find log files and results
design_name=""
if [ "$gen_vpr_route" == "yes" ]; then
    cd $WORKING_DIR/*_golden                     # go to _golden directory
elif [ "$gen_stamp_route" == "yes" ]; then
    cd $WORKING_DIR/*_stamp
fi
design_name=$(awk '/^create_design/ {print $2}' raptor.tcl)     # find the name of the design from raptor.tcl file
device_name=$(awk '/^target_device/ {print $2}' raptor.tcl)     # find the name of the device from raptor.tcl file
top_module=$(awk '/^set_top_module/ {print $2}' raptor.tcl)     # find the name of the design from raptor.tcl file

echo "design name is: $design_name"
echo "device name is: $device_name"
echo "top module is: $top_module"
# Extract size (XxY) using regular expression
if [[ $device_name =~ GEMINI_COMPACT_([0-9]+x[0-9]+) ]]; then
    size="${BASH_REMATCH[1]}"
    device_name="castor${size}_heterogeneous"
else
    echo "ERROR: Unkown format for device name: $device_name"
fi
echo "modified device name to: $device_name"
echo -e "\n\n\n"

if [ -d $design_name ]; then
    cd $design_name         # go to design_name subdirectory
    echo "pwd = $(pwd)"
else
    echo "ERROR: design_name subdirectory $design_name not found. If running only cp_run, skip this error"
fi


# Determine the testbench dir
vpr_testbench_dir=$WORKING_DIR/route_stats/vpr

stamp_testbench_dir=$WORKING_DIR/route_stats/stamp
if [ "$g_safe" == "true" ]; then
        stamp_testbench_dir=$WORKING_DIR/route_stats/stamp_gsafe_true
else
        stamp_testbench_dir=$WORKING_DIR/route_stats/stamp_gsafe_false
fi

################################ VPR Routing ################################ BEGIN
if [ "$gen_vpr_route" == "yes" ] && [ -d "../$design_name" ]; then
    # This part assumes Raptor is already run and we already have the results of VPR run in the current test case directory (i.e., gen_bs is run before)

    # create a new directory for this testbench if it is not already created
    if [ "$clean" == "yes" ]; then
        [ -d $vpr_testbench_dir ] && rm -fr $vpr_testbench_dir
        mkdir -p $vpr_testbench_dir
    else
        [ -d $vpr_testbench_dir ] || mkdir -p $vpr_testbench_dir
    fi


    # Search for timing report file and store its absolute path
    vpr_setup_timing_addr=$(find . -type d -name "*timing_analysis" -exec find {} -type f -name "report_timing.setup.rpt" \; -print -quit | head -n 1)
    # Check if the file was found
    if [ -n "$vpr_setup_timing_addr" ]; then
        echo "Found VPR setup timing file: $vpr_setup_timing_addr"
        cp "$vpr_setup_timing_addr" "$vpr_testbench_dir"
        vpr_setup_timing_addr="$(realpath $vpr_setup_timing_addr)"
    else
        echo "ERROR: No VPR setup timing file found. If running only cp_run, skip this error"
    fi

    # Search for .route file and store its absolute path
    vpr_route_addr=$(find . -type d -name "*_stamp" -prune -o -type f -name "*.route" -print -quit)
    # Check if the file was found
    if [ -n "$vpr_route_addr" ]; then
        echo "Found VPR .route file: $vpr_route_addr"
        cp "$vpr_route_addr" "$vpr_testbench_dir"
        vpr_route_addr="$(realpath $vpr_route_addr)"
    else
        echo "ERROR: No VPR .route file found. If running only cp_run, skip this error"
    fi
    
    

    # Search for .place file and store its absolute path
    vpr_place_addr=$(find . -type d -name "*_stamp" -prune -o -type f -name "*_post_synth.place" -print -quit)
    # Check if the file was found
    if [ -n "$vpr_place_addr" ]; then
        echo "Found VPR _post_synth.place file: $vpr_place_addr"
        cp "$vpr_place_addr" "$vpr_testbench_dir"
    else
        echo "ERROR: No VPR _post_synth.place file found. Looking for .place file... If running only cp_run, skip this error"
        vpr_place_addr=$(find . -type d -name "*_stamp" -prune -o -type f -name "*.place" -print -quit)
        if [ -n "$vpr_place_addr" ]; then
            echo "Found VPR .place file: $vpr_place_addr"
        else
            echo "ERROR: No VPR .place file found. If running only cp_run, skip this error"
        fi
    fi
    

    # Search for .net file and store its absolute path
    vpr_net_addr=$(find . -type d -name "*_stamp" -prune -o -type f -name "*_post_synth.net" -print -quit)
    # Check if the file was found
    if [ -n "$vpr_net_addr" ]; then
        echo "Found VPR _post_synth.net file: $vpr_net_addr"
        cp "$vpr_net_addr" "$vpr_testbench_dir"
    else
        echo "ERROR: No VPR _post_synth.net file found. Looking for .net file... If running only cp_run, skip this error"
        vpr_net_addr=$(find . -type d -name "*_stamp" -prune -o -type f -name "*.net" -print -quit)
        if [ -n "$vpr_net_addr" ]; then
            echo "Found VPR .net file: $vpr_net_addr"
        else
            echo "ERROR: No VPR .net file found. If running only cp_run, skip this error"
        fi
    fi
    

    # Source directory to search for vpr_stdout.log files
    source_directory="."

    # Destination directory to copy the vpr_stdout.log files
    destination_directory="$vpr_testbench_dir"

    # Find vpr_stdout.log files and copy them to the destination directory
    find "$source_directory" -type f -name "vpr_stdout*" -exec sh -c 'cp "$0" "$1/$(basename "$(dirname "$0")")_$(basename "$0")"' {} "$destination_directory" \;


    
    vpr_rrg_addr=$vpr_rr_graph
    arch_addr=$vpr_xml
    pin_map_addr=$pinmap_file
    echo "vpr_route_addr: $vpr_route_addr"
    echo "vpr_rrg_addr: $vpr_rrg_addr"
    echo "arch_addr: $arch_addr"
    echo "pin_map_addr: $pin_map_addr"

    # Check if the routing was successful:
    file_path="$destination_directory/routing_vpr_stdout.log"
    search_line="VPR failed to implement circuit"
    echo "check if the routing succeeds in $file_path"

    if grep -qF "$search_line" "$file_path"; then
        echo "Routing did not succeed --> Not generating any report. Exit the run..."
        echo -e "\n\n\n"
        exit
    else
        echo "Routing succeeded"
    fi
    
    cd $vpr_testbench_dir
    echo -e "\n\n\n"
fi
################################ VPR Routing ################################ END


################################ Stamp Routing ################################ BEGIN
debug="false" # this option is true only when we want to run VPR/OpenFPGA commands directly and not using Raptor
if [ "$gen_stamp_route" == "yes" ] && [ "$debug" == "true" ] && [ -d "../$design_name" ]; then

    # create a new directory for this testbench for stamp routing if it is not already created
    if [ "$clean" == "yes" ]; then
        [ -d $stamp_testbench_dir ] && rm -fr $stamp_testbench_dir
        mkdir -p $stamp_testbench_dir
    else
        [ -d $stamp_testbench_dir ] || mkdir -p $stamp_testbench_dir
    fi
    echo "module load $LATEST_MODULE ..."
    module load $LATEST_MODULE 

    # Search for top_module file and store its absolute path
    top_module_post=$(find . -type d -name "*_stamp" -prune -o -type f -name "*_post_synth.v*" -print -quit)
    # Check if the file was found
    if [ -n "$top_module_post" ]; then
        echo "Found post synthesis top module file: $top_module_post"
    else
        echo "ERROR: No post synthesis top module file found."
        exit
    fi
    top_module_post="$(realpath $top_module_post)"

    sdc_addr=$(find . -type d -name "*_stamp" -prune -o -type f -name "*_openfpga.sdc" -print -quit)
    # Check if the file was found
    if [ -n "$sdc_addr" ]; then
        echo "Found _openfpga.sdc file: $sdc_addr"
    else
        echo "ERROR: No _openfpga.sdc file found."
        exit
    fi
    sdc_addr="$(realpath $sdc_addr)"

    [ -d ./stamp_run ] && rm -fr ./stamp_run
    mkdir -p ./stamp_run
    cd ./stamp_run

    modified_command_1="$VPR_BIN_DIR $vpr_xml $top_module_post --sdc_file $sdc_addr --route_chan_width 640 --suppress_warnings check_rr_node_warnings.log,check_rr_node --clock_modeling ideal --timing_report_npaths 100 --absorb_buffer_luts off --skip_sync_clustering_and_routing_results off --constant_net_method route --timing_report_detail detailed --post_place_timing_report $design_name\_post_place_timing.rpt --device $device_name --allow_unrelated_clustering on --allow_dangling_combinational_nodes on --place_delta_delay_matrix_calculation_method dijkstra --gen_post_synthesis_netlist on --post_synth_netlist_unconn_inputs gnd --inner_loop_recompute_divider 1 --max_router_iterations 1500 --read_rr_graph $stamp_rr_graph --pack $pin_util"
    echo "running gen_stamp_route - modified_command_1: $modified_command_1"
    eval "$modified_command_1" 2>&1 | tee vpr_stamp_stdout_1.log
    echo -e "\n\n\n"

    modified_command_2="$VPR_BIN_DIR $vpr_xml $top_module_post --sdc_file $sdc_addr --route_chan_width 640 --suppress_warnings check_rr_node_warnings.log,check_rr_node --clock_modeling ideal --timing_report_npaths 100 --absorb_buffer_luts off --skip_sync_clustering_and_routing_results off --constant_net_method route --timing_report_detail detailed --post_place_timing_report $design_name\_post_place_timing.rpt --device $device_name --allow_unrelated_clustering on --allow_dangling_combinational_nodes on --place_delta_delay_matrix_calculation_method dijkstra --gen_post_synthesis_netlist on --post_synth_netlist_unconn_inputs gnd --inner_loop_recompute_divider 1 --max_router_iterations 1500 --read_rr_graph $stamp_rr_graph --place"
    echo "running gen_stamp_route - modified_command_2: $modified_command_2"
    eval "$modified_command_2" 2>&1 | tee vpr_stamp_stdout_2.log
    echo -e "\n\n\n"
    
    modified_command_3="$VPR_BIN_DIR $vpr_xml $top_module_post --sdc_file $sdc_addr --route_chan_width 640 --suppress_warnings check_rr_node_warnings.log,check_rr_node --clock_modeling ideal --timing_report_npaths 100 --absorb_buffer_luts off --skip_sync_clustering_and_routing_results off --constant_net_method route --timing_report_detail detailed --post_place_timing_report $design_name\_post_place_timing.rpt --device $device_name --allow_unrelated_clustering on --allow_dangling_combinational_nodes on --place_delta_delay_matrix_calculation_method dijkstra --gen_post_synthesis_netlist on --post_synth_netlist_unconn_inputs gnd --inner_loop_recompute_divider 1 --max_router_iterations 1500 --read_rr_graph $stamp_rr_graph --generate_rr_node_overuse_report on --route"
    echo "running gen_stamp_route - modified_command_3: $modified_command_3"
    eval "$modified_command_3" 2>&1 | tee vpr_stamp_stdout_3.log
    echo -e "\n\n\n"

    file_path="vpr_stamp_stdout_3.log"
    search_line="VPR failed to implement circuit"

    if grep -qF "$search_line" "$file_path"; then
        echo "Routing did not succeed"
        echo -e "\n\n\n"
        exit
    fi
    
    
    net_file=$(find . -maxdepth 1 -type f -name "*_post_synth.net" -print -quit)
    net_file="$(realpath $net_file)"
    place_file=$(find . -maxdepth 1 -type f -name "*_post_synth.place" -print -quit)
    place_file="$(realpath $place_file)"
    route_file=$(find . -maxdepth 1 -type f -name "*_post_synth.route" -print -quit)
    route_file="$(realpath $route_file)"

    modified_command_4="$VPR_BIN_DIR $vpr_xml $top_module_post --sdc_file $sdc_addr --net_file $net_file --place_file $place_file --route_file $route_file --route_chan_width 640 --suppress_warnings check_rr_node_warnings.log,check_rr_node --clock_modeling ideal --timing_report_npaths 100 --absorb_buffer_luts off --skip_sync_clustering_and_routing_results off --constant_net_method route --timing_report_detail detailed --post_place_timing_report $design_name\_post_place_timing.rpt --device $device_name --allow_unrelated_clustering on --allow_dangling_combinational_nodes on --place_delta_delay_matrix_calculation_method dijkstra --gen_post_synthesis_netlist on --post_synth_netlist_unconn_inputs gnd --inner_loop_recompute_divider 1 --max_router_iterations 1500 --read_rr_graph $stamp_rr_graph --analysis"
    echo "running gen_stamp_route - modified_command_4: $modified_command_4"
    eval "$modified_command_4" 2>&1 | tee vpr_stamp_stdout_4.log
    echo -e "\n\n\n"

    file_path="vpr_stamp_stdout_4.log"
    search_line="VPR succeeded"

    if grep -qF "$search_line" "$file_path"; then
        echo "VPR succeeded."
    else
        echo "VPR did not succeed."
    fi
    echo -e "\n\n\n"
    

    # create a .openfpga file for the test case and run the script
    if [ "$run_openfpga" == "yes" ]; then
        
        vpr_command="vpr $vpr_xml $top_module_post --clock_modeling ideal --device $device_name --net_file $net_file --place_file $place_file --route_file $route_file --route_chan_width 640 --sdc_file $sdc_addr --absorb_buffer_luts off --constant_net_method route --skip_sync_clustering_and_routing_results on --circuit_format verilog --analysis --allow_unrelated_clustering on --allow_dangling_combinational_nodes on --place_delta_delay_matrix_calculation_method dijkstra --read_rr_graph $stamp_rr_graph --top $top_module"
        read_openfpga_arch="read_openfpga_arch -f $FLOW_INPUTS/openfpga_arch_annotated.xml"
        read_openfpga_simulation_setting="read_openfpga_simulation_setting -f /nfs_cadtools/softwares/raptor/instl_dir/latest/share/raptor/etc/devices/gemini_compact_${max_x}x${max_y}/fixed_sim_openfpga.xml"
        read_openfpga_bitstream_setting="read_openfpga_bitstream_setting -f /nfs_cadtools/softwares/raptor/instl_dir/latest/share/raptor/etc/devices/gemini_compact_${max_x}x${max_y}/bitstream_setting.xml"
        link_openfpga_arch="link_openfpga_arch --sort_gsb_chan_node_in_edges"
        write_gsb="write_gsb_to_xml -f gsb_output"
        pb_pin_fixup="pb_pin_fixup"
        lut_truth_table_fixup="lut_truth_table_fixup"
        build_fabric="build_fabric --frame_view --compress_routing --duplicate_grid_pin"
        repack="repack --design_constraints /nfs_cadtools/softwares/raptor/instl_dir/latest/share/raptor/etc/devices/gemini_compact_${max_x}x${max_y}/fpga_repack_constraints.xml"
        build_architecture_bitstream="build_architecture_bitstream"
        # build_fabric_bitstream="build_fabric_bitstream --read_file /nfs_cadtools/softwares/raptor/instl_dir/latest/share/raptor/etc/devices/gemini_compact_${max_x}x${max_y}/bitstream_cache.bin"
        build_fabric_bitstream="build_fabric_bitstream"
        # write_fabric_bitstream="write_fabric_bitstream --format plain_text --file fabric_bitstream.bit"
        write_fabric_bitstream="write_fabric_bitstream --keep_dont_care_bits  --format plain_text --file fabric_bitstream.bit"
        write_fabric_bitstream_2="write_fabric_bitstream --format xml --file fabric_bitstream.xml"
        write_io_mapping="write_io_mapping -f PinMapping.xml"
        exit_script="exit"

        echo "creating $design_name.openfpga file..."

        openfpga_file="$design_name.openfpga"
        touch "$openfpga_file"

        echo "# VPR Command" > $openfpga_file
        echo "$vpr_command" >> $openfpga_file
        echo -e "\n" >> $openfpga_file

        echo "# Read OpenFPGA architecture definition" >> $openfpga_file
        echo "$read_openfpga_arch" >> $openfpga_file
        echo -e "\n" >> $openfpga_file

        echo "# Read OpenFPGA simulation settings" >> $openfpga_file
        echo "$read_openfpga_simulation_setting" >> $openfpga_file
        echo -e "\n" >> $openfpga_file

        echo "# Read OpenFPGA bitstream settings" >> $openfpga_file
        echo "$read_openfpga_bitstream_setting" >> $openfpga_file
        echo -e "\n" >> $openfpga_file

        echo "# Annotate the OpenFPGA architecture to VPR data base" >> $openfpga_file
        echo "# to debug use --verbose options" >> $openfpga_file
        echo "$link_openfpga_arch" >> $openfpga_file
        echo -e "\n" >> $openfpga_file

        echo "# write GSBs to gsb_output directory" >> $openfpga_file
        echo "$write_gsb" >> $openfpga_file

        echo "$pb_pin_fixup" >> $openfpga_file
        echo -e "\n" >> $openfpga_file

        echo "# Apply fix-up to Look-Up Table truth tables based on packing results" >> $openfpga_file
        echo "$lut_truth_table_fixup" >> $openfpga_file
        echo -e "\n" >> $openfpga_file


        echo "# Build the module graph" >> $openfpga_file
        echo "#  - Enabled compression on routing architecture modules" >> $openfpga_file
        echo "#  - Enable pin duplication on grid modules" >> $openfpga_file
        echo "$build_fabric" >> $openfpga_file
        echo -e "\n" >> $openfpga_file


        echo "# Repack the netlist to physical pbs" >> $openfpga_file
        echo "# This must be done before bitstream generator and testbench generation" >> $openfpga_file
        echo "# Strongly recommend it is done after all the fix-up have been applied" >> $openfpga_file
        echo "$repack" >> $openfpga_file
        echo -e "\n" >> $openfpga_file

        echo "$build_architecture_bitstream" >> $openfpga_file
        echo -e "\n" >> $openfpga_file


        echo "$build_fabric_bitstream" >> $openfpga_file
        echo "$write_fabric_bitstream" >> $openfpga_file
        echo "$write_fabric_bitstream_2" >> $openfpga_file
        echo "$write_io_mapping" >> $openfpga_file
        echo -e "\n" >> $openfpga_file


        echo "# Finish and exit OpenFPGA" >> $openfpga_file
        echo "$exit_script" >> $openfpga_file
        echo -e "$design_name.openfpga file created\n"

        echo "running $design_name.openfpga..."

        echo "module load $LATEST_MODULE..."
        module load $LATEST_MODULE
        (eval "$OPENFPGA_BIN_DIR -batch -f $design_name.openfpga" 2>&1 | tee openfpga_stamp_stdout.log)
        
        #(eval "/nfs_cadtools/softwares/raptor/instl_dir/latest/bin/openfpga -batch -f $design_name.openfpga" 2>&1 | tee openfpga_stamp_stdout.log)

        echo -e "$design_name.openfpga run finished\n"

    fi

    cp $route_file "$stamp_testbench_dir"
    cp $place_file "$stamp_testbench_dir"
    cp $net_file "$stamp_testbench_dir"
    cp vpr_stamp_stdout* "$stamp_testbench_dir"
    cp openfpga_stamp_stdout* "$stamp_testbench_dir"

    stamp_route_addr=$(realpath *.route)
    stamp_rrg_addr=$stamp_rr_graph
    arch_addr=$vpr_xml
    pin_map_addr=$pinmap_file
    echo "stamp_route_addr: $stamp_route_addr"
    echo "stamp_rrg_addr: $stamp_rrg_addr"
    echo "arch_addr: $arch_addr"
    echo "pin_map_addr: $pin_map_addr"
    echo -e "\n\n\n"

    cd $stamp_testbench_dir
    echo -e "\n\n\n"
fi

if [ "$gen_stamp_route" == "yes" ] && [ "$debug" == "false" ] && [ -d "../$design_name" ]; then
    # This part assumes Raptor is already run and we already have the results of VPR run in the current test case directory (i.e., gen_bs_stamp is run before)

    # create a new directory for this testbench for stamp routing if it is not already created
    if [ "$clean" == "yes" ]; then
        [ -d $stamp_testbench_dir ] && rm -fr $stamp_testbench_dir
        mkdir -p $stamp_testbench_dir
    else
        [ -d $stamp_testbench_dir ] || mkdir -p $stamp_testbench_dir
    fi

    
    # Search for timing report file and store its absolute path
    stamp_setup_timing_addr=$(find . -type d -name "*timing_analysis" -exec find {} -type f -name "report_timing.setup.rpt" \; -print -quit | head -n 1)
    # Check if the file was found
    if [ -n "$stamp_setup_timing_addr" ]; then
        echo "Found Stamp setup timing file: $stamp_setup_timing_addr"
        cp "$stamp_setup_timing_addr" "$stamp_testbench_dir"
        stamp_setup_timing_addr="$(realpath $stamp_setup_timing_addr)"
    else
        echo "ERROR: No Stamp setup timing file found. If running only cp_run, skip this error"
    fi

    # Search for .route file and store its absolute path
    stamp_route_addr=$(find . -type f -name "*.route" -print -quit)
    # Check if the file was found
    if [ -n "$stamp_route_addr" ]; then
    echo "Found Stamp .route file: $stamp_route_addr"
    cp "$stamp_route_addr" "$stamp_testbench_dir"
    stamp_route_addr="$(realpath $stamp_route_addr)"
    else
    echo "ERROR: No Stamp .route file found. If running only cp_run, skip this error"
    fi
    
    

    # Search for .place file and store its absolute path
    stamp_place_addr=$(find . -type f -name "*_post_synth.place" -print -quit)
    # Check if the file was found
    if [ -n "$stamp_place_addr" ]; then
        echo "Found Stamp _post_synth.place file: $stamp_place_addr"
        cp "$stamp_place_addr" "$stamp_testbench_dir"
    else
        echo "ERROR: No Stamp _post_synth.place file found. If running only cp_run, skip this error"
        stamp_place_addr=$(find . -type f -name "*.place" -print -quit)
        if [ -n "$stamp_place_addr" ]; then
            echo "Found Stamp .place file: $stamp_place_addr"
        else
            echo "ERROR: No Stamp .place file found. If running only cp_run, skip this error"
        fi
    fi
    

    # Search for .net file and store its absolute path
    stamp_net_addr=$(find . -type f -name "*_post_synth.net" -print -quit)
    # Check if the file was found
    if [ -n "$stamp_net_addr" ]; then
        echo "Found Stamp _post_synth.net file: $stamp_net_addr"
        cp "$stamp_net_addr" "$stamp_testbench_dir"
    else
        echo "ERROR: No Stamp _post_synth.net file found. Looking for .net file... If running only cp_run, skip this error"
        stamp_net_addr=$(find . -type f -name "*.net" -print -quit)
        if [ -n "$stamp_net_addr" ]; then
            echo "Found Stamp .net file: $stamp_net_addr"
        else
            echo "ERROR: No Stamp .net file found. If running only cp_run, skip this error"
        fi
    fi
    

    # Source directory to search for vpr_stdout.log files
    source_directory="."

    # Destination directory to copy the vpr_stdout.log files
    destination_directory="$stamp_testbench_dir"

    # Find vpr_stdout.log files and copy them to the destination directory
    find "$source_directory" -type f -name "vpr_stdout*" -exec sh -c 'cp "$0" "$1/$(basename "$(dirname "$0")")_$(basename "$0")"' {} "$destination_directory" \;


    stamp_rrg_addr=$stamp_rr_graph
    arch_addr=$vpr_xml
    pin_map_addr=$pinmap_file
    echo "stamp_route_addr: $stamp_route_addr"
    echo "stamp_rrg_addr: $stamp_rrg_addr"
    echo "arch_addr: $arch_addr"
    echo "pin_map_addr: $pin_map_addr"
    
    # Check if the routing was successful:
    file_path="$destination_directory/routing_vpr_stdout.log"
    search_line="VPR failed to implement circuit"
    echo "check if the routing succeeds in $file_path"

    if grep -qF "$search_line" "$file_path"; then
        echo "Routing did not succeed --> Not generating any report. Exit the run..."
        echo -e "\n\n\n"
        exit
    else
        echo "Routing succeeded"
    fi

    cd $stamp_testbench_dir
    echo -e "\n\n\n"
fi
################################ Stamp Routing ################################ END


############################ node-based statistics ############################ BEGIN
if [ "$gen_vpr_route" == "yes" ]; then

    if [ "$gen_nd_tx" == "yes" ]; then
        [ -d $vpr_testbench_dir/node_based ] || mkdir -p $vpr_testbench_dir/node_based
        cd $vpr_testbench_dir/node_based
        echo "generating textual node-based statistics only for this testbench"
        python3 $EVALROUTE/node_statistics.py $arch_addr $vpr_rrg_addr $vpr_route_addr $vpr_setup_timing_addr 2> node_statistics.log > $design_name.report
    fi

    if [ "$gen_nd_vs" == "yes" ]; then
        [ -d $vpr_testbench_dir/node_based ] || mkdir -p $vpr_testbench_dir/node_based
        cd $vpr_testbench_dir/node_based
        echo "generating visulaized node-based statistics only for this testbench"
        python3 $EVALROUTE/plot_results.py $vpr_testbench_dir/node_based  2> plot_results.log > plot_results.out
    fi
    echo -e "\n\n\n"
fi


if [ "$gen_stamp_route" == "yes" ]; then

    if [ "$gen_nd_tx" == "yes" ]; then
        [ -d $stamp_testbench_dir/node_based ] || mkdir -p $stamp_testbench_dir/node_based
        cd $stamp_testbench_dir/node_based
        echo "generating stamp routing textual node-based statistics only for this testbench"
        python3 $EVALROUTE/node_statistics.py $arch_addr $stamp_rrg_addr $stamp_route_addr $stamp_setup_timing_addr 2> node_statistics.log > $design_name\_stamp.report
    fi

    if [ "$gen_nd_vs" == "yes" ]; then

        [ -d $stamp_testbench_dir/node_based ] || mkdir -p $stamp_testbench_dir/node_based
        cd $stamp_testbench_dir/node_based
        echo "generating stamp routing visulaized node-based statistics only for this testbench"
        python3 $EVALROUTE/plot_results.py $stamp_testbench_dir/node_based  2> plot_results.log > plot_results.out

    fi
    echo -e "\n\n\n"

fi
############################ node-based statistics ############################ END


############################ edge-based statistics ############################ BEGIN
if [ "$gen_vpr_route" == "yes" ]; then

    if [ "$gen_eb_no" == "yes" ]; then
        echo "generating edge-based statistics when opin=0"
        [ -d $vpr_testbench_dir/edge_based_not_OPINs ] || mkdir -p $vpr_testbench_dir/edge_based_not_OPINs
        cd $vpr_testbench_dir/edge_based_not_OPINs
        python3 $EVALROUTE/edge_statistics.py $arch_addr $vpr_rrg_addr $vpr_route_addr $pin_map_addr 'opins=0' 2> edge_statistics.log > edge_statistics.out
        python3 $EVALROUTE/mux_histogram_gen.py mux_histogram_not_OPINs 2> mux_histogram_gen.log > mux_histogram_gen.out
    fi

    if [ "$gen_eb_wo" == "yes" ]; then
        echo "generating edge-based statistics when opin=1"
        [ -d $vpr_testbench_dir/edge_based_with_OPINs ] || mkdir -p $vpr_testbench_dir/edge_based_with_OPINs
        cd $vpr_testbench_dir/edge_based_with_OPINs
        python3 $EVALROUTE/edge_statistics.py $arch_addr $vpr_rrg_addr $vpr_route_addr $pin_map_addr 'opins=1' 2> edge_statistics.log > edge_statistics.out
        python3 $EVALROUTE/mux_histogram_gen.py mux_histogram_with_OPINs 2> mux_histogram_gen.log > mux_histogram_gen.out
    fi
    echo -e "\n\n\n"
fi


if [ "$gen_stamp_route" == "yes" ]; then

    echo "generating stamp routing edge-based statistics (version 2)"
    [ -d $stamp_testbench_dir/edge_based ] || mkdir -p $stamp_testbench_dir/edge_based
    cd $stamp_testbench_dir/edge_based
    python3 $EVALROUTE/edge_statistics_2.py SR $FLOW_INPUTS $stamp_route_addr 2> edge_statistics.log > edge_statistics.out

    # if [ "$gen_eb_no" == "yes" ]; then
    #     echo "generating stamp routing edge-based statistics when opin=0"
    #     [ -d $stamp_testbench_dir/edge_based_not_OPINs ] || mkdir -p $stamp_testbench_dir/edge_based_not_OPINs
    #     cd $stamp_testbench_dir/edge_based_not_OPINs
    #     python3 $EVALROUTE/edge_statistics.py $arch_addr $stamp_rrg_addr $stamp_route_addr $pin_map_addr 'opins=0' 2> edge_statistics.log > edge_statistics.out
    #     python3 $EVALROUTE/mux_histogram_gen.py mux_histogram_not_OPINs 2> mux_histogram_gen.log > mux_histogram_gen.out
    # fi

    # if [ "$gen_eb_wo" == "yes" ]; then
    #     echo "generating stamp routing edge-based statistics when opin=1"
    #     [ -d $stamp_testbench_dir/edge_based_with_OPINs ] || mkdir -p $stamp_testbench_dir/edge_based_with_OPINs
    #     cd $stamp_testbench_dir/edge_based_with_OPINs
    #     python3 $EVALROUTE/edge_statistics.py $arch_addr $stamp_rrg_addr $stamp_route_addr $pin_map_addr 'opins=1' 2> edge_statistics.log > edge_statistics.out
    #     python3 $EVALROUTE/mux_histogram_gen.py mux_histogram_with_OPINs 2> mux_histogram_gen.log > mux_histogram_gen.out
    # fi
fi
############################ edge-based statistics ############################ END

if [ -n "$cp_run" ]; then
    
    cd $WORKING_DIR

    echo "copying _golden/_stamp directory to $cp_run ..."

    [ -d $cp_run ] || mkdir -p $cp_run

    cp -rp $WORKING_DIR/rtl $cp_run
    cp -rp $WORKING_DIR/constraints.sdc $cp_run

    if [ "$gen_vpr_route" == "yes" ]; then
        cp -rp $WORKING_DIR/*_golden $cp_run
        # cp -rp $WORKING_DIR/route_stats/vpr $cp_run/route_stats
    elif [ "$gen_stamp_route" == "yes" ]; then
        if [ "$vpr_based_stamp_run" == "yes" ]; then
            [ -d $cp_run/$design_name\_stamp ] || mkdir -p $cp_run/$design_name\_stamp
            cp -rp $WORKING_DIR/*_golden/*              $cp_run/$design_name\_stamp
            cp -rp $WORKING_DIR/*_stamp/raptor.tcl      $cp_run/$design_name\_stamp
            # cp -rp $WORKING_DIR/*_stamp/raptor_cmd.tcl  $cp_run/$design_name\_stamp
        else
            cp -rp $WORKING_DIR/*_stamp $cp_run/$design_name
        fi
        # if [ "$g_safe" == "true" ]; then
        #     cp -rp $WORKING_DIR/route_stats/stamp_gsafe_true $cp_run/route_stats
        # elif [ "$g_safe" == "false" ]; then
        #     cp -rp $WORKING_DIR/route_stats/stamp_gsafe_false $cp_run/route_stats
        # fi
    fi
fi

echo -e "\n\n\n"
echo -e "END OF SCRIPT"