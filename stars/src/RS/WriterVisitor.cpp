#include "pinc_log.h"

// vpr/src/base
#include "atom_netlist.h"
#include "atom_netlist_utils.h"
#include "globals.h"
#include "logic_vec.h"
#include "netlist_walker.h"
#include "vpr_types.h"
#include "vtr_version.h"

// vpr/src/timing
#include "AnalysisDelayCalculator.h"
#include "net_delay.h"

#include "rsGlobal.h"
#include "rsVPR.h"
#include "sta_file_writer.h"
#include "sta_lib_writer.h"
#include "WriterVisitor.h"

namespace rsbe {

using std::endl;
using std::string;
using std::stringstream;
using std::ostream;
using std::vector;
using namespace pinc;

WriterVisitor::WriterVisitor(
                 ostream& verilog_os,
                 ostream& sdf_os,
                 ostream& lib_os,
                 const AnalysisDelayCalculator* del_calc,
                 const t_analysis_opts& opts)
  : verilog_os_(verilog_os),
    sdf_os_(sdf_os),
    lib_os_(lib_os),
    delay_calc_(del_calc),
    opts_(opts) {
  assert(delay_calc_);
  auto& atom_ctx = g_vpr_ctx.atom();

  // Initialize the pin to tnode look-up
  for (AtomPinId pin : atom_ctx.nlist.pins()) {
    AtomBlockId blk = atom_ctx.nlist.pin_block(pin);
    ClusterBlockId clb_idx = atom_ctx.lookup.atom_clb(blk);

    const t_pb_graph_pin* gpin = atom_ctx.lookup.atom_pin_pb_graph_pin(pin);
    assert(gpin);
    int pb_pin_idx = gpin->pin_count_in_cluster;

    tatum::NodeId tnode_id = atom_ctx.lookup.atom_pin_tnode(pin);

    auto key = std::make_pair(clb_idx, pb_pin_idx);
    auto value = std::make_pair(key, tnode_id);
    auto ret = pin_id_to_tnode_lookup_.insert(value);
    VTR_ASSERT_MSG(ret.second, "Was inserted");
    assert(ret.second);
  }
}

WriterVisitor::~WriterVisitor() { }

void WriterVisitor::visit_atom_impl(const t_pb* atom) {
  auto& atom_ctx = g_vpr_ctx.atom();

  auto atom_pb = atom_ctx.lookup.pb_atom(atom);
  if (atom_pb == AtomBlockId::INVALID()) {
    return;
  }
  const t_model* model = atom_ctx.nlist.block_model(atom_pb);

  if (model->name == string(MODEL_INPUT)) {
    inputs_.emplace_back(make_io(atom, PortType::INPUT));
  } else if (model->name == string(MODEL_OUTPUT)) {
    outputs_.emplace_back(make_io(atom, PortType::OUTPUT));
  } else if (model->name == string(MODEL_NAMES)) {
    all_cells_.push_back(make_lut_cell(atom));
  } else if (model->name == string(MODEL_LATCH)) {
    all_cells_.push_back(make_latch_instance(atom));
  } else if (model->name == string("single_port_ram")) {
    all_cells_.push_back(make_ram_instance(atom));
  } else if (model->name == string("dual_port_ram")) {
    all_cells_.push_back(make_ram_instance(atom));
  } else if (model->name == string("multiply")) {
    all_cells_.push_back(make_multiply_instance(atom));
  } else if (model->name == string("adder")) {
    all_cells_.push_back(make_adder_instance(atom));
  } else {
    all_cells_.push_back(make_blackbox_instance(atom));
  }
}

void WriterVisitor::finish_impl() {
  uint16_t tr = ltrace();
  if (tr >= 2) lputs("WriterVisitor::finish_impl()");

  // bh2( __FILE__, __LINE__, " WriterVisitor::finish_impl() " );

  printLib();
  printSDF();
  printVerilog();
}

void WriterVisitor::print_primary_io(int depth) {
  // Primary Inputs
  for (auto iter = inputs_.begin(); iter != inputs_.end(); ++iter) {
    verilog_os_ << indent(depth + 1) << "input " << escape_verilog_identifier(*iter);
    if (iter + 1 != inputs_.end() || outputs_.size() > 0) {
      verilog_os_ << ",";
    }
    verilog_os_ << "\n";
  }
  // Primary Outputs
  for (auto iter = outputs_.begin(); iter != outputs_.end(); ++iter) {
    verilog_os_ << indent(depth + 1) << "output " << escape_verilog_identifier(*iter);
    if (iter + 1 != outputs_.end()) {
      verilog_os_ << ",";
    }
    verilog_os_ << "\n";
  }
}

// virtual
void WriterVisitor::print_assignments(int depth) {
  verilog_os_ << "\n";
  verilog_os_ << indent(depth + 1) << "//IO assignments\n";
  for (auto& assign : assignments_) {
    assign.printVerilog(verilog_os_, indent(depth + 1));
  }
}

///@brief Writes out the verilog netlist
void WriterVisitor::printVerilog(int depth) {
  uint16_t tr = ltrace();
  if (tr >= 2) {
    lprintf("\n  WrVisitor::printVerilog( depth= %i )  all_cells_.size()= %zu\n",
            depth, all_cells_.size());
  }

  verilog_os_ << indent(depth) << "//Verilog generated by VPR " << vtr::VERSION
              << " from post-place-and-route implementation\n";
  verilog_os_ << indent(depth) << "module " << top_module_name_ << " (\n";

  print_primary_io(depth);
  verilog_os_ << indent(depth) << ");\n";

  // Wire declarations
  verilog_os_ << "\n";
  verilog_os_ << indent(depth + 1) << "//Wires\n";
  for (auto& kv : logical_net_drivers_) {
    verilog_os_ << indent(depth + 1) << "wire " << escape_verilog_identifier(kv.second.first) << ";\n";
  }
  for (auto& kv : logical_net_sinks_) {
    for (auto& wire_tnode_pair : kv.second) {
      verilog_os_ << indent(depth + 1) << "wire " << escape_verilog_identifier(wire_tnode_pair.first)
                  << ";\n";
    }
  }

  // connections between primary I/Os and their internal wires
  print_assignments(depth);

  // Interconnect between cell instances
  verilog_os_ << "\n";
  verilog_os_ << indent(depth + 1) << "//Interconnect\n";
  for (const auto& kv : logical_net_sinks_) {
    auto atom_net_id = kv.first;
    auto driver_iter = logical_net_drivers_.find(atom_net_id);
    assert(driver_iter != logical_net_drivers_.end());
    const auto& driver_wire = driver_iter->second.first;

    for (auto& sink_wire_tnode_pair : kv.second) {
      string inst_name = interconnect_name(driver_wire, sink_wire_tnode_pair.first);
      verilog_os_ << indent(depth + 1) << "fpga_interconnect " << escape_verilog_identifier(inst_name)
                  << " (\n";
      verilog_os_ << indent(depth + 2) << ".datain(" << escape_verilog_identifier(driver_wire) << "),\n";
      verilog_os_ << indent(depth + 2) << ".dataout("
                  << escape_verilog_identifier(sink_wire_tnode_pair.first) << ")\n";
      verilog_os_ << indent(depth + 1) << ");\n\n";
    }
  }

  // All the cell instances (to an internal buffer for now)
  stringstream instances_ss;

  size_t unconn_count = 0;
  for (const Cell* inst : all_cells_) {
    inst->printVerilog(instances_ss, unconn_count, depth + 1);
  }

  // Unconnected wires declarations
  if (unconn_count) {
    verilog_os_ << "\n";
    verilog_os_ << indent(depth + 1) << "//Unconnected wires\n";
    for (size_t i = 0; i < unconn_count; ++i) {
      string name = str::concat(FileWriter::unconn_prefix, std::to_string(i));
      verilog_os_ << indent(depth + 1) << "wire " << escape_verilog_identifier(name) << ";\n";
    }
  }

  // All the cell instances
  verilog_os_ << "\n";
  verilog_os_ << indent(depth + 1) << "//Cell instances\n";
  verilog_os_ << instances_ss.str();

  verilog_os_ << "\n";
  verilog_os_ << indent(depth) << "endmodule\n";
}

void WriterVisitor::printLib(int depth) {
  uint16_t tr = ltrace();
  if (tr >= 2) {
    lprintf("  WrVisitor::printLib( depth= %i )  all_cells_.size()= %zu\n",
            depth, all_cells_.size());
  }

  std::set<string> written_cells;

  LibWriter lib_writer;
  lib_writer.write_header(lib_os_);

  // this is hard coded, need to be re-written
  lib_writer.write_bus_type(lib_os_, 0, 3, false);
  lib_writer.write_bus_type(lib_os_, 0, 4, false);
  lib_writer.write_bus_type(lib_os_, 0, 5, false);

  // Interconnect
  // create lcell info
  LCell lc_intercon;
  lc_intercon.setName("fpga_interconnect");
  lc_intercon.setType(INTERCONNECT);

  LibPin pin_in;
  pin_in.setName("datain");
  pin_in.setWidth(1);
  pin_in.setDirection(INPUT);
  pin_in.setType(DATA);
  lc_intercon.add_input(pin_in);
  LibPin pin_out;
  pin_out.setName("dataout");
  pin_out.setWidth(1);
  pin_out.setDirection(OUTPUT);
  pin_out.setType(DATA);

  PinArc arc;
  arc.setSense(POSITIVE);
  arc.setType(TRANSITION);
  arc.setRelatedPin(pin_in);

  pin_out.add_timing_arc(arc);
  lc_intercon.add_output(pin_out);
  lib_writer.write_lcell(lib_os_, lc_intercon);
  written_cells.insert("fpga_interconnect");

  // cells
  string tname;
  for (const Cell* cell : all_cells_) {
    tname = cell->get_type_name();
    if (tr >= 4) {
      lprintf("  tname %s\n", tname.c_str());
    }
    if (not written_cells.count(tname)) {
      cell->printLib(lib_writer, lib_os_);
      written_cells.insert(tname);
    }
  }

  // footer
  lib_writer.write_footer(lib_os_);
  lib_os_.flush();

  if (tr >= 3) {
    lprintf("--WrVisitor::printLib: written %zu lcells\n", written_cells.size());
    if (tr >= 4) {
      for (const string& ws : written_cells) {
        lprintf(" \t %s\n", ws.c_str());
      }
    }
  }
}

///@brief Writes out the SDF
void WriterVisitor::printSDF(int depth) {
  uint16_t tr = ltrace();
  if (tr >= 2) {
    lprintf("\n  WVisitor::printSDF( depth= %i )  all_cells_.size()= %zu\n", depth, all_cells_.size());
  }

  sdf_os_ << indent(depth) << "(DELAYFILE\n";
  sdf_os_ << indent(depth + 1) << "(SDFVERSION \"2.1\")\n";
  sdf_os_ << indent(depth + 1) << "(DESIGN \"" << top_module_name_ << "\")\n";
  sdf_os_ << indent(depth + 1) << "(VENDOR \"verilog-to-routing\")\n";
  sdf_os_ << indent(depth + 1) << "(PROGRAM \"vpr\")\n";
  sdf_os_ << indent(depth + 1) << "(VERSION \"" << vtr::VERSION << "\")\n";
  sdf_os_ << indent(depth + 1) << "(DIVIDER /)\n";
  sdf_os_ << indent(depth + 1) << "(TIMESCALE 1 ps)\n";
  sdf_os_ << "\n";

  // Interconnect
  for (const auto& kv : logical_net_sinks_) {
    auto atom_net_id = kv.first;
    auto driver_iter = logical_net_drivers_.find(atom_net_id);
    assert(driver_iter != logical_net_drivers_.end());
    auto driver_wire = driver_iter->second.first;
    auto driver_tnode = driver_iter->second.second;

    for (auto& sink_wire_tnode_pair : kv.second) {
      auto sink_wire = sink_wire_tnode_pair.first;
      auto sink_tnode = sink_wire_tnode_pair.second;

      sdf_os_ << indent(depth + 1) << "(CELL\n";
      sdf_os_ << indent(depth + 2) << "(CELLTYPE \"fpga_interconnect\")\n";
      sdf_os_ << indent(depth + 2) << "(INSTANCE "
              << escape_sdf_identifier(interconnect_name(driver_wire, sink_wire)) << ")\n";
      sdf_os_ << indent(depth + 2) << "(DELAY\n";
      sdf_os_ << indent(depth + 3) << "(ABSOLUTE\n";

      double delay = get_delay_ps(driver_tnode, sink_tnode);

      stringstream delay_triple;
      delay_triple << "(" << delay << ":" << delay << ":" << delay << ")";

      sdf_os_ << indent(depth + 4) << "(IOPATH datain dataout " << delay_triple.str() << " "
              << delay_triple.str() << ")\n";
      sdf_os_ << indent(depth + 3) << ")\n";
      sdf_os_ << indent(depth + 2) << ")\n";
      sdf_os_ << indent(depth + 1) << ")\n";
      sdf_os_ << indent(depth) << "\n";
    }
  }

  // Cells
  for (const Cell* inst : all_cells_) {
    inst->printSDF(sdf_os_, depth + 1);
  }

  sdf_os_ << indent(depth) << ")\n";
}

/**
 * @brief Returns the name of a circuit-level Input/Output
 *
 * The I/O is recorded and instantiated by the top level output routines
 *   @param atom  The implementation primitive representing the I/O
 *   @param dir   The IO direction
 */
string WriterVisitor::make_io(const t_pb* atom, PortType dir) {
  const t_pb_graph_node* pb_graph_node = atom->pb_graph_node;

  string io_name;
  int cluster_pin_idx = -1;
  if (dir == PortType::INPUT) {
    assert(pb_graph_node->num_output_ports == 1);                             // One output port
    assert(pb_graph_node->num_output_pins[0] == 1);                           // One output pin
    cluster_pin_idx = pb_graph_node->output_pins[0][0].pin_count_in_cluster;  // Unique pin index in cluster

    io_name = atom->name;

  } else {
    assert(pb_graph_node->num_input_ports == 1);                             // One input port
    assert(pb_graph_node->num_input_pins[0] == 1);                           // One input pin
    cluster_pin_idx = pb_graph_node->input_pins[0][0].pin_count_in_cluster;  // Unique pin index in cluster

    // Strip off the starting 'out:' that vpr adds to uniqify outputs
    // this makes the port names match the input blif file
    io_name = atom->name + 4;
  }

  const auto& top_pb_route = find_top_pb_route(atom);

  if (top_pb_route.count(cluster_pin_idx)) {
    // Net exists
    auto atom_net_id = top_pb_route[cluster_pin_idx].atom_net_id;  // Connected net in atom netlist

    // Port direction is inverted (inputs drive internal nets, outputs sink
    // internal nets)
    PortType wire_dir = (dir == PortType::INPUT) ? PortType::OUTPUT : PortType::INPUT;

    // Look up the tnode associated with this pin (used for delay
    // calculation)
    tatum::NodeId tnode_id = find_tnode(atom, cluster_pin_idx);

    auto wire_name = make_inst_wire(atom_net_id, tnode_id, io_name, wire_dir, 0, 0);

    // Connect the wires to to I/Os with assign statements
    if (wire_dir == PortType::INPUT) {
      assignments_.emplace_back(io_name, wire_name);
    } else {
      assignments_.emplace_back(wire_name, io_name);
    }
  }

  return io_name;
}

/**
 * @brief Returns the name of a wire connecting a primitive and global net.
 *
 * The wire is recorded and instantiated by the top level output routines.
 */
string WriterVisitor::make_inst_wire(
                      AtomNetId atom_net_id,   ///< The id of the net in the atom netlist
                      tatum::NodeId tnode_id,  ///< The tnode associated with the primitive pin
                      string inst_name,        ///< The name of the instance associated with the pin
                      PortType port_type,      ///< The port direction
                      int port_idx,            ///< The instance port index
                      int pin_idx) {           ///< The instance pin index

  string wire_name = inst_name;
  if (port_type == PortType::INPUT) {
    wire_name = join_identifier(wire_name, "input");
  } else if (port_type == PortType::CLOCK) {
    wire_name = join_identifier(wire_name, "clock");
  } else {
    assert(port_type == PortType::OUTPUT);
    wire_name = join_identifier(wire_name, "output");
  }

  wire_name = join_identifier(wire_name, std::to_string(port_idx));
  wire_name = join_identifier(wire_name, std::to_string(pin_idx));

  auto value = std::make_pair(wire_name, tnode_id);
  if (port_type == PortType::INPUT || port_type == PortType::CLOCK) {
    // Add the sink
    logical_net_sinks_[atom_net_id].push_back(value);

  } else {
    // Add the driver
    assert(port_type == PortType::OUTPUT);

    auto ret = logical_net_drivers_.insert(std::make_pair(atom_net_id, value));
    assert(ret.second);  // Was inserted, drivers are unique
  }

  return wire_name;
}

///@brief Returns an Cell object representing the LUT
Cell* WriterVisitor::make_lut_cell(const t_pb* atom) noexcept {
  assert(atom);
  const t_pb& atm = *atom;
  // Determine what size LUT
  uint lut_size = count_atom_inputs(atm);
  assert(lut_size > 0);

  // Determine the truth table
  auto lut_mask = load_lut_mask(lut_size, atom);

  // Determine the instance name
  string inst_name = join_identifier("lut", atom->name);

  uint16_t tr = ltrace();
  if (tr >= 5) {
    lprintf("make_lut_cell() lut_size= %u  inst_name= %s\n",
            lut_size, inst_name.c_str());
  }

  // Determine the port connections
  std::map<string, vector<string>> port_conns;

  const t_pb_graph_node* pb_graph_node = atom->pb_graph_node;
  assert(pb_graph_node->num_input_ports == 1);  // LUT has one input port

  const auto& top_pb_route = find_top_pb_route(atom);

  assert(pb_graph_node->num_output_ports == 1);    // LUT has one output port
  assert(pb_graph_node->num_output_pins[0] == 1);  // LUT has one output
                                                   // pin
  int sink_cluster_pin_idx =
      pb_graph_node->output_pins[0][0].pin_count_in_cluster;  // Unique pin index in cluster

  // Add inputs connections
  vector<Arc> timing_arcs;
  for (int pin_idx = 0; pin_idx < pb_graph_node->num_input_pins[0]; pin_idx++) {
    int cluster_pin_idx =
        pb_graph_node->input_pins[0][pin_idx].pin_count_in_cluster;  // Unique pin index in cluster

    string net;
    if (!top_pb_route.count(cluster_pin_idx)) {
      // Disconnected
      net = "";
    } else {
      // Connected to a net
      auto atom_net_id = top_pb_route[cluster_pin_idx].atom_net_id;  // Connected net in atom netlist
      assert(atom_net_id);

      // Look up the tnode associated with this pin (used for delay
      // calculation)
      tatum::NodeId src_tnode_id = find_tnode(atom, cluster_pin_idx);
      tatum::NodeId sink_tnode_id = find_tnode(atom, sink_cluster_pin_idx);

      net = make_inst_wire(atom_net_id, src_tnode_id, inst_name, PortType::INPUT, 0, pin_idx);

      // Record the timing arc
      float delay = get_delay_ps(src_tnode_id, sink_tnode_id);

      Arc timing_arc("in", pin_idx, "out", 0, delay);

      timing_arcs.push_back(timing_arc);
    }
    port_conns["in"].push_back(net);
  }

  // Add the single output connection
  {
    auto atom_net_id = top_pb_route[sink_cluster_pin_idx].atom_net_id;  // Connected net in atom netlist

    string net;
    if (!atom_net_id) {
      // Disconnected
      net = "";
    } else {
      // Connected to a net

      // Look up the tnode associated with this pin (used for delay
      // calculation)
      tatum::NodeId tnode_id = find_tnode(atom, sink_cluster_pin_idx);

      net = make_inst_wire(atom_net_id, tnode_id, inst_name, PortType::OUTPUT, 0, 0);
    }
    port_conns["out"].push_back(net);
  }

  LutCell* inst = new LutCell(lut_size, lut_mask, inst_name, port_conns, timing_arcs, opts_);

  return inst;
}

///@brief Returns an Cell object representing the Latch
Cell* WriterVisitor::make_latch_instance(const t_pb* atom) {
  string inst_name = join_identifier("latch", atom->name);

  const auto& top_pb_route = find_top_pb_route(atom);
  const t_pb_graph_node* pb_graph_node = atom->pb_graph_node;

  // We expect a single input, output and clock ports
  assert(pb_graph_node->num_input_ports == 1);
  assert(pb_graph_node->num_output_ports == 1);
  assert(pb_graph_node->num_clock_ports == 1);
  assert(pb_graph_node->num_input_pins[0] == 1);
  assert(pb_graph_node->num_output_pins[0] == 1);
  assert(pb_graph_node->num_clock_pins[0] == 1);

  // The connections
  std::map<string, string> port_conns;

  // Input (D)
  int input_cluster_pin_idx =
      pb_graph_node->input_pins[0][0].pin_count_in_cluster;  // Unique pin index in cluster
  assert(top_pb_route.count(input_cluster_pin_idx));
  auto input_atom_net_id =
      top_pb_route[input_cluster_pin_idx].atom_net_id;  // Connected net in atom netlist
  string input_net = make_inst_wire(input_atom_net_id, find_tnode(atom, input_cluster_pin_idx), inst_name,
                                    PortType::INPUT, 0, 0);
  port_conns["D"] = input_net;

  double tsu = pb_graph_node->input_pins[0][0].tsu;

  // Output (Q)
  int output_cluster_pin_idx =
      pb_graph_node->output_pins[0][0].pin_count_in_cluster;  // Unique pin index in cluster
  assert(top_pb_route.count(output_cluster_pin_idx));
  auto output_atom_net_id =
      top_pb_route[output_cluster_pin_idx].atom_net_id;  // Connected net in atom netlist
  string output_net = make_inst_wire(output_atom_net_id, find_tnode(atom, output_cluster_pin_idx),
                                     inst_name, PortType::OUTPUT, 0, 0);
  port_conns["Q"] = output_net;

  double tcq = pb_graph_node->output_pins[0][0].tco_max;

  // Clock (control)
  int control_cluster_pin_idx =
      pb_graph_node->clock_pins[0][0].pin_count_in_cluster;  // Unique pin index in cluster
  assert(top_pb_route.count(control_cluster_pin_idx));
  auto control_atom_net_id =
      top_pb_route[control_cluster_pin_idx].atom_net_id;  // Connected net in atom netlist
  string control_net = make_inst_wire(control_atom_net_id, find_tnode(atom, control_cluster_pin_idx),
                                      inst_name, PortType::CLOCK, 0, 0);
  port_conns["clock"] = control_net;

  // VPR currently doesn't store enough information to determine these
  // attributes, for now assume reasonable defaults.
  LatchInst::Type type = LatchInst::Type::RISING_EDGE;
  vtr::LogicValue init_value = vtr::LogicValue::FALSE;

  return new LatchInst(inst_name, port_conns, type, init_value, tcq, tsu);
}

/**
 * @brief Returns an Cell object representing the RAM
 * @note  the primtive interface to dual and single port rams is nearly
 * identical, so we using a single function to handle both
 */
Cell* WriterVisitor::make_ram_instance(const t_pb* atom) {
  const auto& top_pb_route = find_top_pb_route(atom);
  const t_pb_graph_node* pb_graph_node = atom->pb_graph_node;
  const t_pb_type* pb_type = pb_graph_node->pb_type;

  assert(pb_type->class_type == MEMORY_CLASS);

  string type = pb_type->model->name;
  string inst_name = join_identifier(type, atom->name);
  std::map<string, string> params;
  std::map<string, string> attrs;
  std::map<string, vector<string>> input_port_conns;
  std::map<string, vector<string>> output_port_conns;
  vector<Arc> timing_arcs;
  std::map<string, sequential_port_delay_pair> ports_tsu;
  std::map<string, sequential_port_delay_pair> ports_thld;
  std::map<string, sequential_port_delay_pair> ports_tcq;

  params["ADDR_WIDTH"] = "0";
  params["DATA_WIDTH"] = "0";

  // Process the input ports
  for (int iport = 0; iport < pb_graph_node->num_input_ports; ++iport) {
    for (int ipin = 0; ipin < pb_graph_node->num_input_pins[iport]; ++ipin) {
      const t_pb_graph_pin* pin = &pb_graph_node->input_pins[iport][ipin];
      const t_port* port = pin->port;
      string port_class = port->port_class;

      int cluster_pin_idx = pin->pin_count_in_cluster;
      string net;
      if (!top_pb_route.count(cluster_pin_idx)) {
        // Disconnected
        net = "";
      } else {
        // Connected
        auto atom_net_id = top_pb_route[cluster_pin_idx].atom_net_id;
        assert(atom_net_id);
        net = make_inst_wire(atom_net_id, find_tnode(atom, cluster_pin_idx), inst_name, PortType::INPUT,
                             iport, ipin);
      }

      // RAMs use a port class specification to identify the purpose of each
      // port
      string port_name;
      if (port_class == "address") {
        port_name = "addr";
        params["ADDR_WIDTH"] = std::to_string(port->num_pins);
      } else if (port_class == "address1") {
        port_name = "addr1";
        params["ADDR_WIDTH"] = std::to_string(port->num_pins);
      } else if (port_class == "address2") {
        port_name = "addr2";
        params["ADDR_WIDTH"] = std::to_string(port->num_pins);
      } else if (port_class == "data_in") {
        port_name = "data";
        params["DATA_WIDTH"] = std::to_string(port->num_pins);
      } else if (port_class == "data_in1") {
        port_name = "data1";
        params["DATA_WIDTH"] = std::to_string(port->num_pins);
      } else if (port_class == "data_in2") {
        port_name = "data2";
        params["DATA_WIDTH"] = std::to_string(port->num_pins);
      } else if (port_class == "write_en") {
        port_name = "we";
      } else if (port_class == "write_en1") {
        port_name = "we1";
      } else if (port_class == "write_en2") {
        port_name = "we2";
      } else {
        VPR_FATAL_ERROR(VPR_ERROR_IMPL_NETLIST_WRITER,
                        "Unrecognized input port class '%s' for primitive '%s' (%s)\n", port_class.c_str(),
                        atom->name, pb_type->name);
      }

      input_port_conns[port_name].push_back(net);
      ports_tsu[port_name] = std::make_pair(pin->tsu, pin->associated_clock_pin->port->name);
    }
  }

  // Process the output ports
  for (int iport = 0; iport < pb_graph_node->num_output_ports; ++iport) {
    for (int ipin = 0; ipin < pb_graph_node->num_output_pins[iport]; ++ipin) {
      const t_pb_graph_pin* pin = &pb_graph_node->output_pins[iport][ipin];
      const t_port* port = pin->port;
      string port_class = port->port_class;

      int cluster_pin_idx = pin->pin_count_in_cluster;

      string net;
      if (!top_pb_route.count(cluster_pin_idx)) {
        // Disconnected
        net = "";
      } else {
        // Connected
        auto atom_net_id = top_pb_route[cluster_pin_idx].atom_net_id;
        assert(atom_net_id);
        net = make_inst_wire(atom_net_id, find_tnode(atom, cluster_pin_idx), inst_name, PortType::OUTPUT,
                             iport, ipin);
      }

      string port_name;
      if (port_class == "data_out") {
        port_name = "out";
      } else if (port_class == "data_out1") {
        port_name = "out1";
      } else if (port_class == "data_out2") {
        port_name = "out2";
      } else {
        VPR_FATAL_ERROR(VPR_ERROR_IMPL_NETLIST_WRITER,
                        "Unrecognized input port class '%s' for primitive '%s' (%s)\n", port_class.c_str(),
                        atom->name, pb_type->name);
      }
      output_port_conns[port_name].push_back(net);
      ports_tcq[port_name] = std::make_pair(pin->tco_max, pin->associated_clock_pin->port->name);
    }
  }

  // Process the clock ports
  for (int iport = 0; iport < pb_graph_node->num_clock_ports; ++iport) {
    assert(pb_graph_node->num_clock_pins[iport] == 1);  // Expect a single clock port

    for (int ipin = 0; ipin < pb_graph_node->num_clock_pins[iport]; ++ipin) {
      const t_pb_graph_pin* pin = &pb_graph_node->clock_pins[iport][ipin];
      const t_port* port = pin->port;
      string port_class = port->port_class;

      int cluster_pin_idx = pin->pin_count_in_cluster;
      assert(top_pb_route.count(cluster_pin_idx));
      auto atom_net_id = top_pb_route[cluster_pin_idx].atom_net_id;

      assert(atom_net_id);  // Must have a clock

      string net = make_inst_wire(atom_net_id, find_tnode(atom, cluster_pin_idx), inst_name,
                                  PortType::CLOCK, iport, ipin);

      if (port_class == "clock") {
        assert(pb_graph_node->num_clock_pins[iport] == 1);  // Expect a single clock pin
        input_port_conns["clock"].push_back(net);
      } else {
        VPR_FATAL_ERROR(VPR_ERROR_IMPL_NETLIST_WRITER,
                        "Unrecognized input port class '%s' for primitive '%s' (%s)\n", port_class.c_str(),
                        atom->name, pb_type->name);
      }
    }
  }

  return new BlackBoxInst(type, inst_name, params, attrs, input_port_conns, output_port_conns,
                          timing_arcs, ports_tsu, ports_thld, ports_tcq, opts_);
}

///@brief Returns an Cell object representing a Multiplier
Cell* WriterVisitor::make_multiply_instance(const t_pb* atom) {
  auto& timing_ctx = g_vpr_ctx.timing();

  const auto& top_pb_route = find_top_pb_route(atom);
  const t_pb_graph_node* pb_graph_node = atom->pb_graph_node;
  const t_pb_type* pb_type = pb_graph_node->pb_type;

  string type_name = pb_type->model->name;
  string inst_name = join_identifier(type_name, atom->name);
  std::map<string, string> params;
  std::map<string, string> attrs;
  std::map<string, vector<string>> input_port_conns;
  std::map<string, vector<string>> output_port_conns;
  vector<Arc> timing_arcs;
  std::map<string, sequential_port_delay_pair> ports_tsu;
  std::map<string, sequential_port_delay_pair> ports_thld;
  std::map<string, sequential_port_delay_pair> ports_tcq;

  params["WIDTH"] = "0";

  // Delay matrix[sink_tnode] -> tuple of source_port_name, pin index, delay
  std::map<tatum::NodeId, vector<std::tuple<string, int, double>>> tnode_delay_matrix;

  // Process the input ports
  for (int iport = 0; iport < pb_graph_node->num_input_ports; ++iport) {
    for (int ipin = 0; ipin < pb_graph_node->num_input_pins[iport]; ++ipin) {
      const t_pb_graph_pin* pin = &pb_graph_node->input_pins[iport][ipin];
      const t_port* port = pin->port;
      params["WIDTH"] = std::to_string(port->num_pins);  // Assume same width on all ports

      int cluster_pin_idx = pin->pin_count_in_cluster;

      string net;
      if (!top_pb_route.count(cluster_pin_idx)) {
        // Disconnected
        net = "";
      } else {
        // Connected
        auto atom_net_id = top_pb_route[cluster_pin_idx].atom_net_id;
        assert(atom_net_id);
        auto src_tnode = find_tnode(atom, cluster_pin_idx);
        net = make_inst_wire(atom_net_id, src_tnode, inst_name, PortType::INPUT, iport, ipin);

        // Delays
        //
        // We record the souce sink tnodes and thier delays here
        for (tatum::EdgeId edge : timing_ctx.graph->node_out_edges(src_tnode)) {
          double delay = delay_calc_->max_edge_delay(*timing_ctx.graph, edge);

          auto sink_tnode = timing_ctx.graph->edge_sink_node(edge);
          tnode_delay_matrix[sink_tnode].emplace_back(port->name, ipin, delay);
        }
      }

      input_port_conns[port->name].push_back(net);
    }
  }

  // Process the output ports
  for (int iport = 0; iport < pb_graph_node->num_output_ports; ++iport) {
    for (int ipin = 0; ipin < pb_graph_node->num_output_pins[iport]; ++ipin) {
      const t_pb_graph_pin* pin = &pb_graph_node->output_pins[iport][ipin];
      const t_port* port = pin->port;

      int cluster_pin_idx = pin->pin_count_in_cluster;
      string net;
      if (!top_pb_route.count(cluster_pin_idx)) {
        // Disconnected
        net = "";
      } else {
        // Connected
        auto atom_net_id = top_pb_route[cluster_pin_idx].atom_net_id;
        assert(atom_net_id);

        auto inode = find_tnode(atom, cluster_pin_idx);
        net = make_inst_wire(atom_net_id, inode, inst_name, PortType::OUTPUT, iport, ipin);

        // Record the timing arcs
        for (auto& data_tuple : tnode_delay_matrix[inode]) {
          auto src_name = std::get<0>(data_tuple);
          auto src_ipin = std::get<1>(data_tuple);
          auto delay = std::get<2>(data_tuple);
          timing_arcs.emplace_back(src_name, src_ipin, port->name, ipin, delay);
        }
      }

      output_port_conns[port->name].push_back(net);
    }
  }

  assert(pb_graph_node->num_clock_ports == 0);  // No clocks

  return new BlackBoxInst(type_name, inst_name, params, attrs, input_port_conns,
                          output_port_conns, timing_arcs, ports_tsu, ports_thld, ports_tcq,
                          opts_);
}

///@brief Returns an Cell object representing an Adder
Cell* WriterVisitor::make_adder_instance(const t_pb* atom) {
  auto& timing_ctx = g_vpr_ctx.timing();

  const auto& top_pb_route = find_top_pb_route(atom);
  const t_pb_graph_node* pb_graph_node = atom->pb_graph_node;
  const t_pb_type* pb_type = pb_graph_node->pb_type;

  string type_name = pb_type->model->name;
  string inst_name = join_identifier(type_name, atom->name);
  std::map<string, string> params;
  std::map<string, string> attrs;
  std::map<string, vector<string>> input_port_conns;
  std::map<string, vector<string>> output_port_conns;
  vector<Arc> timing_arcs;
  std::map<string, sequential_port_delay_pair> ports_tsu;
  std::map<string, sequential_port_delay_pair> ports_thld;
  std::map<string, sequential_port_delay_pair> ports_tcq;

  params["WIDTH"] = "0";

  // Delay matrix[sink_tnode] -> tuple of source_port_name, pin index, delay
  std::map<tatum::NodeId, vector<std::tuple<string, int, double>>> tnode_delay_matrix;

  // Process the input ports
  for (int iport = 0; iport < pb_graph_node->num_input_ports; ++iport) {
    for (int ipin = 0; ipin < pb_graph_node->num_input_pins[iport]; ++ipin) {
      const t_pb_graph_pin* pin = &pb_graph_node->input_pins[iport][ipin];
      const t_port* port = pin->port;

      if (port->name == string("a") || port->name == string("b")) {
        params["WIDTH"] = std::to_string(port->num_pins);  // Assume same width on all ports
      }

      int cluster_pin_idx = pin->pin_count_in_cluster;

      string net;
      if (!top_pb_route.count(cluster_pin_idx)) {
        // Disconnected
        net = "";
      } else {
        // Connected
        auto atom_net_id = top_pb_route[cluster_pin_idx].atom_net_id;
        assert(atom_net_id);

        // Connected
        auto src_tnode = find_tnode(atom, cluster_pin_idx);
        net = make_inst_wire(atom_net_id, src_tnode, inst_name, PortType::INPUT, iport, ipin);

        // Delays
        //
        // We record the souce sink tnodes and thier delays here
        for (tatum::EdgeId edge : timing_ctx.graph->node_out_edges(src_tnode)) {
          double delay = delay_calc_->max_edge_delay(*timing_ctx.graph, edge);

          auto sink_tnode = timing_ctx.graph->edge_sink_node(edge);
          tnode_delay_matrix[sink_tnode].emplace_back(port->name, ipin, delay);
        }
      }

      input_port_conns[port->name].push_back(net);
    }
  }

  // Process the output ports
  for (int iport = 0; iport < pb_graph_node->num_output_ports; ++iport) {
    for (int ipin = 0; ipin < pb_graph_node->num_output_pins[iport]; ++ipin) {
      const t_pb_graph_pin* pin = &pb_graph_node->output_pins[iport][ipin];
      const t_port* port = pin->port;

      int cluster_pin_idx = pin->pin_count_in_cluster;

      string net;
      if (!top_pb_route.count(cluster_pin_idx)) {
        // Disconnected
        net = "";
      } else {
        // Connected
        auto atom_net_id = top_pb_route[cluster_pin_idx].atom_net_id;
        assert(atom_net_id);

        auto inode = find_tnode(atom, cluster_pin_idx);
        net = make_inst_wire(atom_net_id, inode, inst_name, PortType::OUTPUT, iport, ipin);

        // Record the timing arcs
        for (auto& data_tuple : tnode_delay_matrix[inode]) {
          auto src_name = std::get<0>(data_tuple);
          auto src_ipin = std::get<1>(data_tuple);
          auto delay = std::get<2>(data_tuple);
          timing_arcs.emplace_back(src_name, src_ipin, port->name, ipin, delay);
        }
      }

      output_port_conns[port->name].push_back(net);
    }
  }

  return new BlackBoxInst(type_name, inst_name, params, attrs, input_port_conns,
                          output_port_conns, timing_arcs, ports_tsu, ports_thld, ports_tcq,
                          opts_);
}

Cell* WriterVisitor::make_blackbox_instance(const t_pb* atom) {
  const auto& top_pb_route = find_top_pb_route(atom);
  const t_pb_graph_node* pb_graph_node = atom->pb_graph_node;
  const t_pb_type* pb_type = pb_graph_node->pb_type;

  auto& timing_ctx = g_vpr_ctx.timing();
  string type_name = pb_type->model->name;
  string inst_name = join_identifier(type_name, atom->name);
  std::map<string, string> params;
  std::map<string, string> attrs;
  std::map<string, vector<string>> input_port_conns;
  std::map<string, vector<string>> output_port_conns;
  vector<Arc> timing_arcs;

  // Maps to store a sink's port with the corresponding timing edge to that
  // sink
  //  - key   : string corresponding to the port's name
  //  - value : pair with the delay and the associated clock pin port name
  //
  //  tsu : Setup
  //  thld: Hold
  //  tcq : Clock-to-Q
  std::map<string, sequential_port_delay_pair> ports_tsu;
  std::map<string, sequential_port_delay_pair> ports_thld;
  std::map<string, sequential_port_delay_pair> ports_tcq;

  // Delay matrix[sink_tnode] -> tuple of source_port_name, pin index, delay
  std::map<tatum::NodeId, vector<std::tuple<string, int, double>>> tnode_delay_matrix;

  // Process the input ports
  for (int iport = 0; iport < pb_graph_node->num_input_ports; ++iport) {
    for (int ipin = 0; ipin < pb_graph_node->num_input_pins[iport]; ++ipin) {
      const t_pb_graph_pin* pin = &pb_graph_node->input_pins[iport][ipin];
      const t_port* port = pin->port;

      int cluster_pin_idx = pin->pin_count_in_cluster;

      string net;
      if (!top_pb_route.count(cluster_pin_idx)) {
        // Disconnected
        net = "";

      } else {
        // Connected
        auto atom_net_id = top_pb_route[cluster_pin_idx].atom_net_id;
        assert(atom_net_id);

        auto src_tnode = find_tnode(atom, cluster_pin_idx);
        net = make_inst_wire(atom_net_id, src_tnode, inst_name, PortType::INPUT, iport, ipin);
        // Delays
        //
        // We record the source's sink tnodes and their delays here
        for (tatum::EdgeId edge : timing_ctx.graph->node_out_edges(src_tnode)) {
          double delay = delay_calc_->max_edge_delay(*timing_ctx.graph, edge);

          auto sink_tnode = timing_ctx.graph->edge_sink_node(edge);
          tnode_delay_matrix[sink_tnode].emplace_back(port->name, ipin, delay);
        }
      }

      input_port_conns[port->name].push_back(net);
      if (pin->type == PB_PIN_SEQUENTIAL) {
        if (!std::isnan(pin->tsu))
          ports_tsu[port->name] = std::make_pair(pin->tsu, pin->associated_clock_pin->port->name);
        if (!std::isnan(pin->thld))
          ports_thld[port->name] = std::make_pair(pin->thld, pin->associated_clock_pin->port->name);
      }
    }
  }

  // Process the output ports
  for (int iport = 0; iport < pb_graph_node->num_output_ports; ++iport) {
    for (int ipin = 0; ipin < pb_graph_node->num_output_pins[iport]; ++ipin) {
      const t_pb_graph_pin* pin = &pb_graph_node->output_pins[iport][ipin];
      const t_port* port = pin->port;

      int cluster_pin_idx = pin->pin_count_in_cluster;

      string net;
      if (!top_pb_route.count(cluster_pin_idx)) {
        // Disconnected
        net = "";
      } else {
        // Connected
        auto atom_net_id = top_pb_route[cluster_pin_idx].atom_net_id;
        assert(atom_net_id);

        auto inode = find_tnode(atom, cluster_pin_idx);
        net = make_inst_wire(atom_net_id, inode, inst_name, PortType::OUTPUT, iport, ipin);
        // Record the timing arcs
        for (auto& data_tuple : tnode_delay_matrix[inode]) {
          auto src_name = std::get<0>(data_tuple);
          auto src_ipin = std::get<1>(data_tuple);
          auto delay = std::get<2>(data_tuple);
          timing_arcs.emplace_back(src_name, src_ipin, port->name, ipin, delay);
        }
      }

      output_port_conns[port->name].push_back(net);
      if (pin->type == PB_PIN_SEQUENTIAL && !std::isnan(pin->tco_max))
        ports_tcq[port->name] = std::make_pair(pin->tco_max, pin->associated_clock_pin->port->name);
    }
  }

  // Process the clock ports
  for (int iport = 0; iport < pb_graph_node->num_clock_ports; ++iport) {
    for (int ipin = 0; ipin < pb_graph_node->num_clock_pins[iport]; ++ipin) {
      const t_pb_graph_pin* pin = &pb_graph_node->clock_pins[iport][ipin];
      const t_port* port = pin->port;

      int cluster_pin_idx = pin->pin_count_in_cluster;

      string net;
      if (!top_pb_route.count(cluster_pin_idx)) {
        // Disconnected
        net = "";
      } else {
        // Connected
        auto atom_net_id = top_pb_route[cluster_pin_idx].atom_net_id;
        assert(atom_net_id);  // Must have a clock

        auto src_tnode = find_tnode(atom, cluster_pin_idx);
        net = make_inst_wire(atom_net_id, src_tnode, inst_name, PortType::CLOCK, iport, ipin);
      }

      input_port_conns[port->name].push_back(net);
    }
  }

  auto& atom_ctx = g_vpr_ctx.atom();
  AtomBlockId blk_id = atom_ctx.lookup.pb_atom(atom);
  for (auto param : atom_ctx.nlist.block_params(blk_id)) {
    params[param.first] = param.second;
  }

  for (auto attr : atom_ctx.nlist.block_attrs(blk_id)) {
    attrs[attr.first] = attr.second;
  }

  return new BlackBoxInst(type_name, inst_name, params, attrs, input_port_conns,
                          output_port_conns, timing_arcs, ports_tsu, ports_thld, ports_tcq,
                          opts_);
}

///@brief Returns a LogicVec representing the LUT mask of the given LUT atom
LogicVec WriterVisitor::load_lut_mask(
                        uint num_inputs,     // LUT size
                        const t_pb* atom) {  // LUT primitive
  uint16_t tr = ltrace();
  auto& ls = lout();
  auto& atom_ctx = g_vpr_ctx.atom();

  const t_model* model = atom_ctx.nlist.block_model(atom_ctx.lookup.pb_atom(atom));
  assert(model->name == string(MODEL_NAMES));

  if (tr >= 4) {
    ls << "\nLoading LUT mask for: " << atom->name << "  num_inputs= " << num_inputs << endl;
  }

  // Figure out how the inputs were permuted (compared to the input netlist)
  vector<int> permute = determine_lut_permutation(num_inputs, atom);

  // Retrieve the truth table
  const auto& truth_table = atom_ctx.nlist.block_truth_table(atom_ctx.lookup.pb_atom(atom));

  // Apply the permutation
  auto permuted_truth_table = permute_truth_table(truth_table, num_inputs, permute);

  // Convert to lut mask
  LogicVec lut_mask = truth_table_to_lut_mask(permuted_truth_table, num_inputs);

  if (tr >= 4) {
    ls << "\tLUT_MASK: " << lut_mask << '\n' << endl;
  }

  return lut_mask;
}

/**
 * @brief Helper function for load_lut_mask() which determines how the LUT
 * inputs were permuted compared to the input BLIF
 *
 * Since the LUT inputs may have been rotated from the input blif
 * specification we need to figure out this permutation to reflect the
 * physical implementation connectivity.
 *
 * We return a permutation map (which is a list of swaps from index to
 * index) which is then applied to do the rotation of the lutmask.
 *
 * The net in the atom netlist which was originally connected to pin i, is
 * connected to pin permute[i] in the implementation.
 */
vector<int> WriterVisitor::determine_lut_permutation(uint num_inputs, const t_pb* atom_pb) {
  uint16_t tr = ltrace();
  auto& ls = lout();
  if (tr >= 4) {
    lprintf("  WVisitor::determine_lut_permutation( num_inputs= %u )\n", num_inputs);
  }
  auto& atom_ctx = g_vpr_ctx.atom();

  vector<int> permute(num_inputs, OPEN);

  if (tr >= 4) {
    ls << "\tInit Permute: {";
    for (size_t i = 0; i < permute.size(); i++) {
      ls << permute[i] << ", ";
    }
    ls << "}" << endl;
  }

  // Determine the permutation
  //
  // We walk through the logical inputs to this atom (i.e. in the original
  // truth table/netlist) and find the corresponding input in the
  // implementation atom (i.e. in the current netlist)
  auto ports = atom_ctx.nlist.block_input_ports(atom_ctx.lookup.pb_atom(atom_pb));
  if (ports.size() == 1) {
    const t_pb_graph_node* gnode = atom_pb->pb_graph_node;
    assert(gnode->num_input_ports == 1);
    assert(gnode->num_input_pins[0] >= (int)num_inputs);

    AtomPortId port_id = *ports.begin();

    for (size_t ipin = 0; ipin < num_inputs; ++ipin) {
      AtomNetId impl_input_net_id =
          find_atom_input_logical_net(atom_pb, ipin);  // The net currently connected to input j

      // Find the original pin index
      const t_pb_graph_pin* gpin = &gnode->input_pins[0][ipin];
      BitIndex orig_index = atom_pb->atom_pin_bit_index(gpin);

      if (impl_input_net_id) {
        // If there is a valid net connected in the implementation
        AtomNetId logical_net_id = atom_ctx.nlist.port_net(port_id, orig_index);

        // Fatal error should be flagged when the net marked in
        // implementation does not match the net marked in input netlist
        if (impl_input_net_id != logical_net_id) {
          VPR_FATAL_ERROR(VPR_ERROR_IMPL_NETLIST_WRITER,
                          "Unmatch:\n\tlogical net is '%s' at pin "
                          "'%lu'\n\timplmented net is '%s' at pin '%s'\n",
                          atom_ctx.nlist.net_name(logical_net_id).c_str(), size_t(orig_index),
                          atom_ctx.nlist.net_name(impl_input_net_id).c_str(), gpin->to_string().c_str());
        }

        // Mark the permutation.
        //  The net originally located at orig_index in the atom netlist
        //  was moved to ipin in the implementation
        permute[orig_index] = ipin;
      }
    }
  } else {
    // May have no inputs on a constant generator
    assert(ports.size() == 0);
  }

  // Fill in any missing values in the permutation (i.e. zeros)
  std::set<int> perm_indicies(permute.begin(), permute.end());
  size_t unused_index = 0;
  for (size_t i = 0; i < permute.size(); i++) {
    if (permute[i] == OPEN) {
      while (perm_indicies.count(unused_index)) {
        unused_index++;
      }
      permute[i] = unused_index;
      perm_indicies.insert(unused_index);
    }
  }

  if (tr >= 5) {
    ls << "\tPermute: {";
    for (int pk : permute) {
      ls << pk << ", ";
    }
    ls << "}" << endl;

    ls << "\tBLIF = Input ->  Rotated" << endl;
    ls << "\t------------------------" << endl;
  }
  return permute;
}

///@brief Returns the logical net ID
AtomNetId WriterVisitor::find_atom_input_logical_net(const t_pb* atom, int atom_input_idx) {
  const t_pb_graph_node* pb_node = atom->pb_graph_node;

  int cluster_pin_idx = pb_node->input_pins[0][atom_input_idx].pin_count_in_cluster;
  const auto& top_pb_route = find_top_pb_route(atom);
  AtomNetId atom_net_id;
  if (top_pb_route.count(cluster_pin_idx)) {
    atom_net_id = top_pb_route[cluster_pin_idx].atom_net_id;
  }
  return atom_net_id;
}

// UNUSED
#if 0
  /**
   * @brief Helper function for load_lut_mask() which determines if the
   *        names is encodeing the ON (returns true) or OFF (returns false)
   * set.
   */
  bool names_encodes_on_set(vtr::t_linked_vptr* names_row_ptr) {
    // Determine the truth (output value) for this row
    // By default we assume the on-set is encoded to correctly handle
    // constant true/false
    //
    // False output:
    //      .names j
    //
    // True output:
    //      .names j
    //      1
    bool encoding_on_set = true;

    // We may get a nullptr if the output is always false
    if (names_row_ptr) {
      // Determine whether the truth table stores the ON or OFF set
      //
      //  In blif, the 'output values' of a .names must be either '1' or '0',
      //  and must be consistent within a single .names -- that is a single
      //  .names can encode either the ON or OFF set (of which only one will
      //  be encoded in a single .names)
      //
      const string names_first_row = (const char*)names_row_ptr->data_vptr;
      auto names_first_row_output_iter = names_first_row.end() - 1;

      if (*names_first_row_output_iter == '1') {
        encoding_on_set = true;
      } else if (*names_first_row_output_iter == '0') {
        encoding_on_set = false;
      } else {
        VPR_FATAL_ERROR(VPR_ERROR_IMPL_NETLIST_WRITER,
                        "Invalid .names truth-table character '%c'. Must be "
                        "one of '1', '0' or '-'. \n",
                        *names_first_row_output_iter);
      }
    }

    return encoding_on_set;
  }
#endif //////000000

// UNUSED
#if 0
  /**
   * @brief Helper function for load_lut_mask()
   *
   * Converts the given names_row string to a LogicVec
   */
  LogicVec names_row_to_logic_vec(const string names_row, size_t num_inputs, bool encoding_on_set) {
    // Get an iterator to the last character (i.e. the output value)
    auto output_val_iter = names_row.end() - 1;

    // Sanity-check, the 2nd last character should be a space
    auto space_iter = names_row.end() - 2;
    assert(*space_iter == ' ');

    // Extract the truth (output value) for this row
    if (*output_val_iter == '1') {
      assert(encoding_on_set);
    } else if (*output_val_iter == '0') {
      assert(!encoding_on_set);
    } else {
      VPR_FATAL_ERROR(VPR_ERROR_IMPL_NETLIST_WRITER, "Invalid .names encoding both ON and OFF set\n");
    }

    // Extract the input values for this row
    LogicVec input_values(num_inputs, vtr::LogicValue::FALSE);
    size_t i = 0;
    // Walk through each input in the input cube for this row
    while (names_row[i] != ' ') {
      vtr::LogicValue input_val = vtr::LogicValue::UNKOWN;
      if (names_row[i] == '1') {
        input_val = vtr::LogicValue::TRUE;
      } else if (names_row[i] == '0') {
        input_val = vtr::LogicValue::FALSE;
      } else if (names_row[i] == '-') {
        input_val = vtr::LogicValue::DONT_CARE;
      } else {
        VPR_FATAL_ERROR(VPR_ERROR_IMPL_NETLIST_WRITER,
                        "Invalid .names truth-table character '%c'. Must be "
                        "one of '1', '0' or '-'. \n",
                        names_row[i]);
      }

      input_values[i] = input_val;
      i++;
    }
    return input_values;
  }
#endif //////000000

}

