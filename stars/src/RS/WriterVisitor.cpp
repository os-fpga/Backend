#include "pinc_log.h"

// vpr/src/base
#include "atom_netlist.h"
#include "atom_netlist_utils.h"
#include "globals.h"
#include "logic_vec.h"
#include "netlist_walker.h"
#include "vpr_types.h"
#include "vtr_version.h"

// vpr/src/timing
#include "AnalysisDelayCalculator.h"
#include "net_delay.h"

#include "rsGlobal.h"
#include "rsVPR.h"
#include "sta_file_writer.h"
#include "sta_lib_data.h"
#include "sta_lib_writer.h"
#include "WriterVisitor.h"

namespace rsbe {

using std::cout;
using std::endl;
using std::string;
using std::stringstream;
using std::ostream;
using std::vector;
using namespace pinc;

StaWriterVisitor::StaWriterVisitor(
                 ostream& verilog_os,
                 ostream& sdf_os,
                 ostream& lib_os,
                 std::shared_ptr<const AnalysisDelayCalculator> delay_calc,
                 const t_analysis_opts& opts)
  : verilog_os_(verilog_os),
    sdf_os_(sdf_os),
    lib_os_(lib_os),
    delay_calc_(delay_calc),
    opts_(opts) {

  auto& atom_ctx = g_vpr_ctx.atom();

  // Initialize the pin to tnode look-up
  for (AtomPinId pin : atom_ctx.nlist.pins()) {
    AtomBlockId blk = atom_ctx.nlist.pin_block(pin);
    ClusterBlockId clb_idx = atom_ctx.lookup.atom_clb(blk);

    const t_pb_graph_pin* gpin = atom_ctx.lookup.atom_pin_pb_graph_pin(pin);
    assert(gpin);
    int pb_pin_idx = gpin->pin_count_in_cluster;

    tatum::NodeId tnode_id = atom_ctx.lookup.atom_pin_tnode(pin);

    auto key = std::make_pair(clb_idx, pb_pin_idx);
    auto value = std::make_pair(key, tnode_id);
    auto ret = pin_id_to_tnode_lookup_.insert(value);
    VTR_ASSERT_MSG(ret.second, "Was inserted");
    assert(ret.second);
  }
}

StaWriterVisitor::~StaWriterVisitor() { }

void StaWriterVisitor::visit_atom_impl(const t_pb* atom) {
  auto& atom_ctx = g_vpr_ctx.atom();

  auto atom_pb = atom_ctx.lookup.pb_atom(atom);
  if (atom_pb == AtomBlockId::INVALID()) {
    return;
  }
  const t_model* model = atom_ctx.nlist.block_model(atom_pb);

  if (model->name == string(MODEL_INPUT)) {
    inputs_.emplace_back(make_io(atom, PortType::INPUT));
  } else if (model->name == string(MODEL_OUTPUT)) {
    outputs_.emplace_back(make_io(atom, PortType::OUTPUT));
  } else if (model->name == string(MODEL_NAMES)) {
    cell_instances_.push_back(make_lut_instance(atom));
  } else if (model->name == string(MODEL_LATCH)) {
    cell_instances_.push_back(make_latch_instance(atom));
  } else if (model->name == string("single_port_ram")) {
    cell_instances_.push_back(make_ram_instance(atom));
  } else if (model->name == string("dual_port_ram")) {
    cell_instances_.push_back(make_ram_instance(atom));
  } else if (model->name == string("multiply")) {
    cell_instances_.push_back(make_multiply_instance(atom));
  } else if (model->name == string("adder")) {
    cell_instances_.push_back(make_adder_instance(atom));
  } else {
    cell_instances_.push_back(make_blackbox_instance(atom));
  }
}

void StaWriterVisitor::finish_impl() {
  uint16_t tr = ltrace();
  if (tr >= 2) lputs("StaWriterVisitor::finish_impl()");

  print_lib();
  print_sdf();
  print_verilog();
}

void StaWriterVisitor::print_primary_io(int depth) {
  // Primary Inputs
  for (auto iter = inputs_.begin(); iter != inputs_.end(); ++iter) {
    verilog_os_ << indent(depth + 1) << "input " << escape_verilog_identifier(*iter);
    if (iter + 1 != inputs_.end() || outputs_.size() > 0) {
      verilog_os_ << ",";
    }
    verilog_os_ << "\n";
  }
  // Primary Outputs
  for (auto iter = outputs_.begin(); iter != outputs_.end(); ++iter) {
    verilog_os_ << indent(depth + 1) << "output " << escape_verilog_identifier(*iter);
    if (iter + 1 != outputs_.end()) {
      verilog_os_ << ",";
    }
    verilog_os_ << "\n";
  }
}

///@brief Writes out the verilog netlist
void StaWriterVisitor::print_verilog(int depth) {
  verilog_os_ << indent(depth) << "//Verilog generated by VPR " << vtr::VERSION
              << " from post-place-and-route implementation\n";
  verilog_os_ << indent(depth) << "module " << top_module_name_ << " (\n";

  print_primary_io(depth);
  verilog_os_ << indent(depth) << ");\n";

  // Wire declarations
  verilog_os_ << "\n";
  verilog_os_ << indent(depth + 1) << "//Wires\n";
  for (auto& kv : logical_net_drivers_) {
    verilog_os_ << indent(depth + 1) << "wire " << escape_verilog_identifier(kv.second.first) << ";\n";
  }
  for (auto& kv : logical_net_sinks_) {
    for (auto& wire_tnode_pair : kv.second) {
      verilog_os_ << indent(depth + 1) << "wire " << escape_verilog_identifier(wire_tnode_pair.first)
                  << ";\n";
    }
  }

  // connections between primary I/Os and their internal wires
  print_assignments(depth);

  // Interconnect between cell instances
  verilog_os_ << "\n";
  verilog_os_ << indent(depth + 1) << "//Interconnect\n";
  for (const auto& kv : logical_net_sinks_) {
    auto atom_net_id = kv.first;
    auto driver_iter = logical_net_drivers_.find(atom_net_id);
    assert(driver_iter != logical_net_drivers_.end());
    const auto& driver_wire = driver_iter->second.first;

    for (auto& sink_wire_tnode_pair : kv.second) {
      string inst_name = interconnect_name(driver_wire, sink_wire_tnode_pair.first);
      verilog_os_ << indent(depth + 1) << "fpga_interconnect " << escape_verilog_identifier(inst_name)
                  << " (\n";
      verilog_os_ << indent(depth + 2) << ".datain(" << escape_verilog_identifier(driver_wire) << "),\n";
      verilog_os_ << indent(depth + 2) << ".dataout("
                  << escape_verilog_identifier(sink_wire_tnode_pair.first) << ")\n";
      verilog_os_ << indent(depth + 1) << ");\n\n";
    }
  }

  // All the cell instances (to an internal buffer for now)
  stringstream instances_ss;

  size_t unconn_count = 0;
  for (auto& inst : cell_instances_) {
    inst->print_verilog(instances_ss, unconn_count, depth + 1);
  }

  // Unconnected wires declarations
  if (unconn_count) {
    verilog_os_ << "\n";
    verilog_os_ << indent(depth + 1) << "//Unconnected wires\n";
    for (size_t i = 0; i < unconn_count; ++i) {
      string name = str::concat(sta_file_writer::unconn_prefix, std::to_string(i));
      verilog_os_ << indent(depth + 1) << "wire " << escape_verilog_identifier(name) << ";\n";
    }
  }

  // All the cell instances
  verilog_os_ << "\n";
  verilog_os_ << indent(depth + 1) << "//Cell instances\n";
  verilog_os_ << instances_ss.str();

  verilog_os_ << "\n";
  verilog_os_ << indent(depth) << "endmodule\n";
}

void StaWriterVisitor::print_lib(int depth) {
  uint16_t tr = ltrace();
  if (tr >= 2)
    lprintf("  StaWriterVisitor::print_lib( depth= %i )\n", depth);

  std::set<string> written_cells;

  sta_lib_writer lib_writer;
  lib_writer.write_header(lib_os_);

  // this is hard coded, need to be re-written
  lib_writer.write_bus_type(lib_os_, 0, 3, false);
  lib_writer.write_bus_type(lib_os_, 0, 4, false);
  lib_writer.write_bus_type(lib_os_, 0, 5, false);

  // Interconnect
  // create cell info
  lib_cell cell;
  cell.name("fpga_interconnect");
  cell.type(INTERCONNECT);
  lib_pin pin_in;
  pin_in.name("datain");
  pin_in.bus_width(1);
  pin_in.direction(INPUT);
  pin_in.type(DATA);
  cell.add_pin(pin_in, INPUT);
  lib_pin pin_out;
  pin_out.name("dataout");
  pin_out.bus_width(1);
  pin_out.direction(OUTPUT);
  pin_out.type(DATA);
  timing_arch timing;
  timing.sense(POSITIVE);
  timing.type(TRANSITION);
  timing.related_pin(pin_in);
  pin_out.add_timing_arch(timing);
  cell.add_pin(pin_out, OUTPUT);
  lib_writer.write_cell(lib_os_, cell);
  written_cells.insert("fpga_interconnect");

  // cells
  for (const auto& inst : cell_instances_) {
    if (written_cells.find(inst->get_type_name()) == written_cells.end()) {
      inst->print_lib(lib_writer, lib_os_);
      written_cells.insert(inst->get_type_name());
    }
  }

  // footer
  lib_writer.write_footer(lib_os_);
}

///@brief Writes out the SDF
void StaWriterVisitor::print_sdf(int depth) {
  sdf_os_ << indent(depth) << "(DELAYFILE\n";
  sdf_os_ << indent(depth + 1) << "(SDFVERSION \"2.1\")\n";
  sdf_os_ << indent(depth + 1) << "(DESIGN \"" << top_module_name_ << "\")\n";
  sdf_os_ << indent(depth + 1) << "(VENDOR \"verilog-to-routing\")\n";
  sdf_os_ << indent(depth + 1) << "(PROGRAM \"vpr\")\n";
  sdf_os_ << indent(depth + 1) << "(VERSION \"" << vtr::VERSION << "\")\n";
  sdf_os_ << indent(depth + 1) << "(DIVIDER /)\n";
  sdf_os_ << indent(depth + 1) << "(TIMESCALE 1 ps)\n";
  sdf_os_ << "\n";

  // Interconnect
  for (const auto& kv : logical_net_sinks_) {
    auto atom_net_id = kv.first;
    auto driver_iter = logical_net_drivers_.find(atom_net_id);
    assert(driver_iter != logical_net_drivers_.end());
    auto driver_wire = driver_iter->second.first;
    auto driver_tnode = driver_iter->second.second;

    for (auto& sink_wire_tnode_pair : kv.second) {
      auto sink_wire = sink_wire_tnode_pair.first;
      auto sink_tnode = sink_wire_tnode_pair.second;

      sdf_os_ << indent(depth + 1) << "(CELL\n";
      sdf_os_ << indent(depth + 2) << "(CELLTYPE \"fpga_interconnect\")\n";
      sdf_os_ << indent(depth + 2) << "(INSTANCE "
              << escape_sdf_identifier(interconnect_name(driver_wire, sink_wire)) << ")\n";
      sdf_os_ << indent(depth + 2) << "(DELAY\n";
      sdf_os_ << indent(depth + 3) << "(ABSOLUTE\n";

      double delay = get_delay_ps(driver_tnode, sink_tnode);

      stringstream delay_triple;
      delay_triple << "(" << delay << ":" << delay << ":" << delay << ")";

      sdf_os_ << indent(depth + 4) << "(IOPATH datain dataout " << delay_triple.str() << " "
              << delay_triple.str() << ")\n";
      sdf_os_ << indent(depth + 3) << ")\n";
      sdf_os_ << indent(depth + 2) << ")\n";
      sdf_os_ << indent(depth + 1) << ")\n";
      sdf_os_ << indent(depth) << "\n";
    }
  }

  // Cells
  for (const auto& inst : cell_instances_) {
    inst->print_sdf(sdf_os_, depth + 1);
  }

  sdf_os_ << indent(depth) << ")\n";
}

/**
 * @brief Returns the name of a circuit-level Input/Output
 *
 * The I/O is recorded and instantiated by the top level output routines
 *   @param atom  The implementation primitive representing the I/O
 *   @param dir   The IO direction
 */
string StaWriterVisitor::make_io(const t_pb* atom, PortType dir) {
  const t_pb_graph_node* pb_graph_node = atom->pb_graph_node;

  string io_name;
  int cluster_pin_idx = -1;
  if (dir == PortType::INPUT) {
    assert(pb_graph_node->num_output_ports == 1);                             // One output port
    assert(pb_graph_node->num_output_pins[0] == 1);                           // One output pin
    cluster_pin_idx = pb_graph_node->output_pins[0][0].pin_count_in_cluster;  // Unique pin index in cluster

    io_name = atom->name;

  } else {
    assert(pb_graph_node->num_input_ports == 1);                             // One input port
    assert(pb_graph_node->num_input_pins[0] == 1);                           // One input pin
    cluster_pin_idx = pb_graph_node->input_pins[0][0].pin_count_in_cluster;  // Unique pin index in cluster

    // Strip off the starting 'out:' that vpr adds to uniqify outputs
    // this makes the port names match the input blif file
    io_name = atom->name + 4;
  }

  const auto& top_pb_route = find_top_pb_route(atom);

  if (top_pb_route.count(cluster_pin_idx)) {
    // Net exists
    auto atom_net_id = top_pb_route[cluster_pin_idx].atom_net_id;  // Connected net in atom netlist

    // Port direction is inverted (inputs drive internal nets, outputs sink
    // internal nets)
    PortType wire_dir = (dir == PortType::INPUT) ? PortType::OUTPUT : PortType::INPUT;

    // Look up the tnode associated with this pin (used for delay
    // calculation)
    tatum::NodeId tnode_id = find_tnode(atom, cluster_pin_idx);

    auto wire_name = make_inst_wire(atom_net_id, tnode_id, io_name, wire_dir, 0, 0);

    // Connect the wires to to I/Os with assign statements
    if (wire_dir == PortType::INPUT) {
      assignments_.emplace_back(io_name, wire_name);
    } else {
      assignments_.emplace_back(wire_name, io_name);
    }
  }

  return io_name;
}

/**
 * @brief Returns the name of a wire connecting a primitive and global net.
 *
 * The wire is recorded and instantiated by the top level output routines.
 */
string StaWriterVisitor::make_inst_wire(
                      AtomNetId atom_net_id,   ///< The id of the net in the atom netlist
                      tatum::NodeId tnode_id,  ///< The tnode associated with the primitive pin
                      string inst_name,        ///< The name of the instance associated with the pin
                      PortType port_type,      ///< The port direction
                      int port_idx,            ///< The instance port index
                      int pin_idx) {           ///< The instance pin index

  string wire_name = inst_name;
  if (port_type == PortType::INPUT) {
    wire_name = join_identifier(wire_name, "input");
  } else if (port_type == PortType::CLOCK) {
    wire_name = join_identifier(wire_name, "clock");
  } else {
    assert(port_type == PortType::OUTPUT);
    wire_name = join_identifier(wire_name, "output");
  }

  wire_name = join_identifier(wire_name, std::to_string(port_idx));
  wire_name = join_identifier(wire_name, std::to_string(pin_idx));

  auto value = std::make_pair(wire_name, tnode_id);
  if (port_type == PortType::INPUT || port_type == PortType::CLOCK) {
    // Add the sink
    logical_net_sinks_[atom_net_id].push_back(value);

  } else {
    // Add the driver
    assert(port_type == PortType::OUTPUT);

    auto ret = logical_net_drivers_.insert(std::make_pair(atom_net_id, value));
    assert(ret.second);  // Was inserted, drivers are unique
  }

  return wire_name;
}

///@brief Returns an Instance object representing the LUT
std::shared_ptr<Instance> StaWriterVisitor::make_lut_instance(const t_pb* atom) {
  // Determine what size LUT
  int lut_size = find_num_inputs(atom);

  // Determine the truth table
  auto lut_mask = load_lut_mask(lut_size, atom);

  // Determine the instance name
  auto inst_name = join_identifier("lut", atom->name);

  // Determine the port connections
  std::map<string, std::vector<string>> port_conns;

  const t_pb_graph_node* pb_graph_node = atom->pb_graph_node;
  assert(pb_graph_node->num_input_ports == 1);  // LUT has one input port

  const auto& top_pb_route = find_top_pb_route(atom);

  assert(pb_graph_node->num_output_ports == 1);    // LUT has one output port
  assert(pb_graph_node->num_output_pins[0] == 1);  // LUT has one output
                                                   // pin
  int sink_cluster_pin_idx =
      pb_graph_node->output_pins[0][0].pin_count_in_cluster;  // Unique pin index in cluster

  // Add inputs connections
  std::vector<Arc> timing_arcs;
  for (int pin_idx = 0; pin_idx < pb_graph_node->num_input_pins[0]; pin_idx++) {
    int cluster_pin_idx =
        pb_graph_node->input_pins[0][pin_idx].pin_count_in_cluster;  // Unique pin index in cluster

    string net;
    if (!top_pb_route.count(cluster_pin_idx)) {
      // Disconnected
      net = "";
    } else {
      // Connected to a net
      auto atom_net_id = top_pb_route[cluster_pin_idx].atom_net_id;  // Connected net in atom netlist
      assert(atom_net_id);

      // Look up the tnode associated with this pin (used for delay
      // calculation)
      tatum::NodeId src_tnode_id = find_tnode(atom, cluster_pin_idx);
      tatum::NodeId sink_tnode_id = find_tnode(atom, sink_cluster_pin_idx);

      net = make_inst_wire(atom_net_id, src_tnode_id, inst_name, PortType::INPUT, 0, pin_idx);

      // Record the timing arc
      float delay = get_delay_ps(src_tnode_id, sink_tnode_id);

      Arc timing_arc("in", pin_idx, "out", 0, delay);

      timing_arcs.push_back(timing_arc);
    }
    port_conns["in"].push_back(net);
  }

  // Add the single output connection
  {
    auto atom_net_id = top_pb_route[sink_cluster_pin_idx].atom_net_id;  // Connected net in atom netlist

    string net;
    if (!atom_net_id) {
      // Disconnected
      net = "";
    } else {
      // Connected to a net

      // Look up the tnode associated with this pin (used for delay
      // calculation)
      tatum::NodeId tnode_id = find_tnode(atom, sink_cluster_pin_idx);

      net = make_inst_wire(atom_net_id, tnode_id, inst_name, PortType::OUTPUT, 0, 0);
    }
    port_conns["out"].push_back(net);
  }

  auto inst = std::make_shared<LutInst>(lut_size, lut_mask, inst_name, port_conns, timing_arcs, opts_);

  return inst;
}

///@brief Returns an Instance object representing the Latch
std::shared_ptr<Instance> StaWriterVisitor::make_latch_instance(const t_pb* atom) {
  string inst_name = join_identifier("latch", atom->name);

  const auto& top_pb_route = find_top_pb_route(atom);
  const t_pb_graph_node* pb_graph_node = atom->pb_graph_node;

  // We expect a single input, output and clock ports
  assert(pb_graph_node->num_input_ports == 1);
  assert(pb_graph_node->num_output_ports == 1);
  assert(pb_graph_node->num_clock_ports == 1);
  assert(pb_graph_node->num_input_pins[0] == 1);
  assert(pb_graph_node->num_output_pins[0] == 1);
  assert(pb_graph_node->num_clock_pins[0] == 1);

  // The connections
  std::map<string, string> port_conns;

  // Input (D)
  int input_cluster_pin_idx =
      pb_graph_node->input_pins[0][0].pin_count_in_cluster;  // Unique pin index in cluster
  assert(top_pb_route.count(input_cluster_pin_idx));
  auto input_atom_net_id =
      top_pb_route[input_cluster_pin_idx].atom_net_id;  // Connected net in atom netlist
  string input_net = make_inst_wire(input_atom_net_id, find_tnode(atom, input_cluster_pin_idx), inst_name,
                                    PortType::INPUT, 0, 0);
  port_conns["D"] = input_net;

  double tsu = pb_graph_node->input_pins[0][0].tsu;

  // Output (Q)
  int output_cluster_pin_idx =
      pb_graph_node->output_pins[0][0].pin_count_in_cluster;  // Unique pin index in cluster
  assert(top_pb_route.count(output_cluster_pin_idx));
  auto output_atom_net_id =
      top_pb_route[output_cluster_pin_idx].atom_net_id;  // Connected net in atom netlist
  string output_net = make_inst_wire(output_atom_net_id, find_tnode(atom, output_cluster_pin_idx),
                                     inst_name, PortType::OUTPUT, 0, 0);
  port_conns["Q"] = output_net;

  double tcq = pb_graph_node->output_pins[0][0].tco_max;

  // Clock (control)
  int control_cluster_pin_idx =
      pb_graph_node->clock_pins[0][0].pin_count_in_cluster;  // Unique pin index in cluster
  assert(top_pb_route.count(control_cluster_pin_idx));
  auto control_atom_net_id =
      top_pb_route[control_cluster_pin_idx].atom_net_id;  // Connected net in atom netlist
  string control_net = make_inst_wire(control_atom_net_id, find_tnode(atom, control_cluster_pin_idx),
                                      inst_name, PortType::CLOCK, 0, 0);
  port_conns["clock"] = control_net;

  // VPR currently doesn't store enough information to determine these
  // attributes, for now assume reasonable defaults.
  LatchInst::Type type = LatchInst::Type::RISING_EDGE;
  vtr::LogicValue init_value = vtr::LogicValue::FALSE;

  return std::make_shared<LatchInst>(inst_name, port_conns, type, init_value, tcq, tsu);
}

/**
 * @brief Returns an Instance object representing the RAM
 * @note  the primtive interface to dual and single port rams is nearly
 * identical, so we using a single function to handle both
 */
std::shared_ptr<Instance> StaWriterVisitor::make_ram_instance(const t_pb* atom) {
  const auto& top_pb_route = find_top_pb_route(atom);
  const t_pb_graph_node* pb_graph_node = atom->pb_graph_node;
  const t_pb_type* pb_type = pb_graph_node->pb_type;

  assert(pb_type->class_type == MEMORY_CLASS);

  string type = pb_type->model->name;
  string inst_name = join_identifier(type, atom->name);
  std::map<string, string> params;
  std::map<string, string> attrs;
  std::map<string, std::vector<string>> input_port_conns;
  std::map<string, std::vector<string>> output_port_conns;
  std::vector<Arc> timing_arcs;
  std::map<string, sequential_port_delay_pair> ports_tsu;
  std::map<string, sequential_port_delay_pair> ports_thld;
  std::map<string, sequential_port_delay_pair> ports_tcq;

  params["ADDR_WIDTH"] = "0";
  params["DATA_WIDTH"] = "0";

  // Process the input ports
  for (int iport = 0; iport < pb_graph_node->num_input_ports; ++iport) {
    for (int ipin = 0; ipin < pb_graph_node->num_input_pins[iport]; ++ipin) {
      const t_pb_graph_pin* pin = &pb_graph_node->input_pins[iport][ipin];
      const t_port* port = pin->port;
      string port_class = port->port_class;

      int cluster_pin_idx = pin->pin_count_in_cluster;
      string net;
      if (!top_pb_route.count(cluster_pin_idx)) {
        // Disconnected
        net = "";
      } else {
        // Connected
        auto atom_net_id = top_pb_route[cluster_pin_idx].atom_net_id;
        assert(atom_net_id);
        net = make_inst_wire(atom_net_id, find_tnode(atom, cluster_pin_idx), inst_name, PortType::INPUT,
                             iport, ipin);
      }

      // RAMs use a port class specification to identify the purpose of each
      // port
      string port_name;
      if (port_class == "address") {
        port_name = "addr";
        params["ADDR_WIDTH"] = std::to_string(port->num_pins);
      } else if (port_class == "address1") {
        port_name = "addr1";
        params["ADDR_WIDTH"] = std::to_string(port->num_pins);
      } else if (port_class == "address2") {
        port_name = "addr2";
        params["ADDR_WIDTH"] = std::to_string(port->num_pins);
      } else if (port_class == "data_in") {
        port_name = "data";
        params["DATA_WIDTH"] = std::to_string(port->num_pins);
      } else if (port_class == "data_in1") {
        port_name = "data1";
        params["DATA_WIDTH"] = std::to_string(port->num_pins);
      } else if (port_class == "data_in2") {
        port_name = "data2";
        params["DATA_WIDTH"] = std::to_string(port->num_pins);
      } else if (port_class == "write_en") {
        port_name = "we";
      } else if (port_class == "write_en1") {
        port_name = "we1";
      } else if (port_class == "write_en2") {
        port_name = "we2";
      } else {
        VPR_FATAL_ERROR(VPR_ERROR_IMPL_NETLIST_WRITER,
                        "Unrecognized input port class '%s' for primitive '%s' (%s)\n", port_class.c_str(),
                        atom->name, pb_type->name);
      }

      input_port_conns[port_name].push_back(net);
      ports_tsu[port_name] = std::make_pair(pin->tsu, pin->associated_clock_pin->port->name);
    }
  }

  // Process the output ports
  for (int iport = 0; iport < pb_graph_node->num_output_ports; ++iport) {
    for (int ipin = 0; ipin < pb_graph_node->num_output_pins[iport]; ++ipin) {
      const t_pb_graph_pin* pin = &pb_graph_node->output_pins[iport][ipin];
      const t_port* port = pin->port;
      string port_class = port->port_class;

      int cluster_pin_idx = pin->pin_count_in_cluster;

      string net;
      if (!top_pb_route.count(cluster_pin_idx)) {
        // Disconnected
        net = "";
      } else {
        // Connected
        auto atom_net_id = top_pb_route[cluster_pin_idx].atom_net_id;
        assert(atom_net_id);
        net = make_inst_wire(atom_net_id, find_tnode(atom, cluster_pin_idx), inst_name, PortType::OUTPUT,
                             iport, ipin);
      }

      string port_name;
      if (port_class == "data_out") {
        port_name = "out";
      } else if (port_class == "data_out1") {
        port_name = "out1";
      } else if (port_class == "data_out2") {
        port_name = "out2";
      } else {
        VPR_FATAL_ERROR(VPR_ERROR_IMPL_NETLIST_WRITER,
                        "Unrecognized input port class '%s' for primitive '%s' (%s)\n", port_class.c_str(),
                        atom->name, pb_type->name);
      }
      output_port_conns[port_name].push_back(net);
      ports_tcq[port_name] = std::make_pair(pin->tco_max, pin->associated_clock_pin->port->name);
    }
  }

  // Process the clock ports
  for (int iport = 0; iport < pb_graph_node->num_clock_ports; ++iport) {
    assert(pb_graph_node->num_clock_pins[iport] == 1);  // Expect a single clock port

    for (int ipin = 0; ipin < pb_graph_node->num_clock_pins[iport]; ++ipin) {
      const t_pb_graph_pin* pin = &pb_graph_node->clock_pins[iport][ipin];
      const t_port* port = pin->port;
      string port_class = port->port_class;

      int cluster_pin_idx = pin->pin_count_in_cluster;
      assert(top_pb_route.count(cluster_pin_idx));
      auto atom_net_id = top_pb_route[cluster_pin_idx].atom_net_id;

      assert(atom_net_id);  // Must have a clock

      string net = make_inst_wire(atom_net_id, find_tnode(atom, cluster_pin_idx), inst_name,
                                  PortType::CLOCK, iport, ipin);

      if (port_class == "clock") {
        assert(pb_graph_node->num_clock_pins[iport] == 1);  // Expect a single clock pin
        input_port_conns["clock"].push_back(net);
      } else {
        VPR_FATAL_ERROR(VPR_ERROR_IMPL_NETLIST_WRITER,
                        "Unrecognized input port class '%s' for primitive '%s' (%s)\n", port_class.c_str(),
                        atom->name, pb_type->name);
      }
    }
  }

  return std::make_shared<BlackBoxInst>(type, inst_name, params, attrs, input_port_conns, output_port_conns,
                                        timing_arcs, ports_tsu, ports_thld, ports_tcq, opts_);
}

///@brief Returns an Instance object representing a Multiplier
std::shared_ptr<Instance> StaWriterVisitor::make_multiply_instance(const t_pb* atom) {
  auto& timing_ctx = g_vpr_ctx.timing();

  const auto& top_pb_route = find_top_pb_route(atom);
  const t_pb_graph_node* pb_graph_node = atom->pb_graph_node;
  const t_pb_type* pb_type = pb_graph_node->pb_type;

  string type_name = pb_type->model->name;
  string inst_name = join_identifier(type_name, atom->name);
  std::map<string, string> params;
  std::map<string, string> attrs;
  std::map<string, std::vector<string>> input_port_conns;
  std::map<string, std::vector<string>> output_port_conns;
  std::vector<Arc> timing_arcs;
  std::map<string, sequential_port_delay_pair> ports_tsu;
  std::map<string, sequential_port_delay_pair> ports_thld;
  std::map<string, sequential_port_delay_pair> ports_tcq;

  params["WIDTH"] = "0";

  // Delay matrix[sink_tnode] -> tuple of source_port_name, pin index, delay
  std::map<tatum::NodeId, std::vector<std::tuple<string, int, double>>> tnode_delay_matrix;

  // Process the input ports
  for (int iport = 0; iport < pb_graph_node->num_input_ports; ++iport) {
    for (int ipin = 0; ipin < pb_graph_node->num_input_pins[iport]; ++ipin) {
      const t_pb_graph_pin* pin = &pb_graph_node->input_pins[iport][ipin];
      const t_port* port = pin->port;
      params["WIDTH"] = std::to_string(port->num_pins);  // Assume same width on all ports

      int cluster_pin_idx = pin->pin_count_in_cluster;

      string net;
      if (!top_pb_route.count(cluster_pin_idx)) {
        // Disconnected
        net = "";
      } else {
        // Connected
        auto atom_net_id = top_pb_route[cluster_pin_idx].atom_net_id;
        assert(atom_net_id);
        auto src_tnode = find_tnode(atom, cluster_pin_idx);
        net = make_inst_wire(atom_net_id, src_tnode, inst_name, PortType::INPUT, iport, ipin);

        // Delays
        //
        // We record the souce sink tnodes and thier delays here
        for (tatum::EdgeId edge : timing_ctx.graph->node_out_edges(src_tnode)) {
          double delay = delay_calc_->max_edge_delay(*timing_ctx.graph, edge);

          auto sink_tnode = timing_ctx.graph->edge_sink_node(edge);
          tnode_delay_matrix[sink_tnode].emplace_back(port->name, ipin, delay);
        }
      }

      input_port_conns[port->name].push_back(net);
    }
  }

  // Process the output ports
  for (int iport = 0; iport < pb_graph_node->num_output_ports; ++iport) {
    for (int ipin = 0; ipin < pb_graph_node->num_output_pins[iport]; ++ipin) {
      const t_pb_graph_pin* pin = &pb_graph_node->output_pins[iport][ipin];
      const t_port* port = pin->port;

      int cluster_pin_idx = pin->pin_count_in_cluster;
      string net;
      if (!top_pb_route.count(cluster_pin_idx)) {
        // Disconnected
        net = "";
      } else {
        // Connected
        auto atom_net_id = top_pb_route[cluster_pin_idx].atom_net_id;
        assert(atom_net_id);

        auto inode = find_tnode(atom, cluster_pin_idx);
        net = make_inst_wire(atom_net_id, inode, inst_name, PortType::OUTPUT, iport, ipin);

        // Record the timing arcs
        for (auto& data_tuple : tnode_delay_matrix[inode]) {
          auto src_name = std::get<0>(data_tuple);
          auto src_ipin = std::get<1>(data_tuple);
          auto delay = std::get<2>(data_tuple);
          timing_arcs.emplace_back(src_name, src_ipin, port->name, ipin, delay);
        }
      }

      output_port_conns[port->name].push_back(net);
    }
  }

  assert(pb_graph_node->num_clock_ports == 0);  // No clocks

  return std::make_shared<BlackBoxInst>(type_name, inst_name, params, attrs, input_port_conns,
                                        output_port_conns, timing_arcs, ports_tsu, ports_thld, ports_tcq,
                                        opts_);
}

///@brief Returns an Instance object representing an Adder
std::shared_ptr<Instance> StaWriterVisitor::make_adder_instance(const t_pb* atom) {
  auto& timing_ctx = g_vpr_ctx.timing();

  const auto& top_pb_route = find_top_pb_route(atom);
  const t_pb_graph_node* pb_graph_node = atom->pb_graph_node;
  const t_pb_type* pb_type = pb_graph_node->pb_type;

  string type_name = pb_type->model->name;
  string inst_name = join_identifier(type_name, atom->name);
  std::map<string, string> params;
  std::map<string, string> attrs;
  std::map<string, std::vector<string>> input_port_conns;
  std::map<string, std::vector<string>> output_port_conns;
  std::vector<Arc> timing_arcs;
  std::map<string, sequential_port_delay_pair> ports_tsu;
  std::map<string, sequential_port_delay_pair> ports_thld;
  std::map<string, sequential_port_delay_pair> ports_tcq;

  params["WIDTH"] = "0";

  // Delay matrix[sink_tnode] -> tuple of source_port_name, pin index, delay
  std::map<tatum::NodeId, std::vector<std::tuple<string, int, double>>> tnode_delay_matrix;

  // Process the input ports
  for (int iport = 0; iport < pb_graph_node->num_input_ports; ++iport) {
    for (int ipin = 0; ipin < pb_graph_node->num_input_pins[iport]; ++ipin) {
      const t_pb_graph_pin* pin = &pb_graph_node->input_pins[iport][ipin];
      const t_port* port = pin->port;

      if (port->name == string("a") || port->name == string("b")) {
        params["WIDTH"] = std::to_string(port->num_pins);  // Assume same width on all ports
      }

      int cluster_pin_idx = pin->pin_count_in_cluster;

      string net;
      if (!top_pb_route.count(cluster_pin_idx)) {
        // Disconnected
        net = "";
      } else {
        // Connected
        auto atom_net_id = top_pb_route[cluster_pin_idx].atom_net_id;
        assert(atom_net_id);

        // Connected
        auto src_tnode = find_tnode(atom, cluster_pin_idx);
        net = make_inst_wire(atom_net_id, src_tnode, inst_name, PortType::INPUT, iport, ipin);

        // Delays
        //
        // We record the souce sink tnodes and thier delays here
        for (tatum::EdgeId edge : timing_ctx.graph->node_out_edges(src_tnode)) {
          double delay = delay_calc_->max_edge_delay(*timing_ctx.graph, edge);

          auto sink_tnode = timing_ctx.graph->edge_sink_node(edge);
          tnode_delay_matrix[sink_tnode].emplace_back(port->name, ipin, delay);
        }
      }

      input_port_conns[port->name].push_back(net);
    }
  }

  // Process the output ports
  for (int iport = 0; iport < pb_graph_node->num_output_ports; ++iport) {
    for (int ipin = 0; ipin < pb_graph_node->num_output_pins[iport]; ++ipin) {
      const t_pb_graph_pin* pin = &pb_graph_node->output_pins[iport][ipin];
      const t_port* port = pin->port;

      int cluster_pin_idx = pin->pin_count_in_cluster;

      string net;
      if (!top_pb_route.count(cluster_pin_idx)) {
        // Disconnected
        net = "";
      } else {
        // Connected
        auto atom_net_id = top_pb_route[cluster_pin_idx].atom_net_id;
        assert(atom_net_id);

        auto inode = find_tnode(atom, cluster_pin_idx);
        net = make_inst_wire(atom_net_id, inode, inst_name, PortType::OUTPUT, iport, ipin);

        // Record the timing arcs
        for (auto& data_tuple : tnode_delay_matrix[inode]) {
          auto src_name = std::get<0>(data_tuple);
          auto src_ipin = std::get<1>(data_tuple);
          auto delay = std::get<2>(data_tuple);
          timing_arcs.emplace_back(src_name, src_ipin, port->name, ipin, delay);
        }
      }

      output_port_conns[port->name].push_back(net);
    }
  }

  return std::make_shared<BlackBoxInst>(type_name, inst_name, params, attrs, input_port_conns,
                                        output_port_conns, timing_arcs, ports_tsu, ports_thld, ports_tcq,
                                        opts_);
}

std::shared_ptr<Instance> StaWriterVisitor::make_blackbox_instance(const t_pb* atom) {
  const auto& top_pb_route = find_top_pb_route(atom);
  const t_pb_graph_node* pb_graph_node = atom->pb_graph_node;
  const t_pb_type* pb_type = pb_graph_node->pb_type;

  auto& timing_ctx = g_vpr_ctx.timing();
  string type_name = pb_type->model->name;
  string inst_name = join_identifier(type_name, atom->name);
  std::map<string, string> params;
  std::map<string, string> attrs;
  std::map<string, std::vector<string>> input_port_conns;
  std::map<string, std::vector<string>> output_port_conns;
  std::vector<Arc> timing_arcs;

  // Maps to store a sink's port with the corresponding timing edge to that
  // sink
  //  - key   : string corresponding to the port's name
  //  - value : pair with the delay and the associated clock pin port name
  //
  //  tsu : Setup
  //  thld: Hold
  //  tcq : Clock-to-Q
  std::map<string, sequential_port_delay_pair> ports_tsu;
  std::map<string, sequential_port_delay_pair> ports_thld;
  std::map<string, sequential_port_delay_pair> ports_tcq;

  // Delay matrix[sink_tnode] -> tuple of source_port_name, pin index, delay
  std::map<tatum::NodeId, std::vector<std::tuple<string, int, double>>> tnode_delay_matrix;

  // Process the input ports
  for (int iport = 0; iport < pb_graph_node->num_input_ports; ++iport) {
    for (int ipin = 0; ipin < pb_graph_node->num_input_pins[iport]; ++ipin) {
      const t_pb_graph_pin* pin = &pb_graph_node->input_pins[iport][ipin];
      const t_port* port = pin->port;

      int cluster_pin_idx = pin->pin_count_in_cluster;

      string net;
      if (!top_pb_route.count(cluster_pin_idx)) {
        // Disconnected
        net = "";

      } else {
        // Connected
        auto atom_net_id = top_pb_route[cluster_pin_idx].atom_net_id;
        assert(atom_net_id);

        auto src_tnode = find_tnode(atom, cluster_pin_idx);
        net = make_inst_wire(atom_net_id, src_tnode, inst_name, PortType::INPUT, iport, ipin);
        // Delays
        //
        // We record the source's sink tnodes and their delays here
        for (tatum::EdgeId edge : timing_ctx.graph->node_out_edges(src_tnode)) {
          double delay = delay_calc_->max_edge_delay(*timing_ctx.graph, edge);

          auto sink_tnode = timing_ctx.graph->edge_sink_node(edge);
          tnode_delay_matrix[sink_tnode].emplace_back(port->name, ipin, delay);
        }
      }

      input_port_conns[port->name].push_back(net);
      if (pin->type == PB_PIN_SEQUENTIAL) {
        if (!std::isnan(pin->tsu))
          ports_tsu[port->name] = std::make_pair(pin->tsu, pin->associated_clock_pin->port->name);
        if (!std::isnan(pin->thld))
          ports_thld[port->name] = std::make_pair(pin->thld, pin->associated_clock_pin->port->name);
      }
    }
  }

  // Process the output ports
  for (int iport = 0; iport < pb_graph_node->num_output_ports; ++iport) {
    for (int ipin = 0; ipin < pb_graph_node->num_output_pins[iport]; ++ipin) {
      const t_pb_graph_pin* pin = &pb_graph_node->output_pins[iport][ipin];
      const t_port* port = pin->port;

      int cluster_pin_idx = pin->pin_count_in_cluster;

      string net;
      if (!top_pb_route.count(cluster_pin_idx)) {
        // Disconnected
        net = "";
      } else {
        // Connected
        auto atom_net_id = top_pb_route[cluster_pin_idx].atom_net_id;
        assert(atom_net_id);

        auto inode = find_tnode(atom, cluster_pin_idx);
        net = make_inst_wire(atom_net_id, inode, inst_name, PortType::OUTPUT, iport, ipin);
        // Record the timing arcs
        for (auto& data_tuple : tnode_delay_matrix[inode]) {
          auto src_name = std::get<0>(data_tuple);
          auto src_ipin = std::get<1>(data_tuple);
          auto delay = std::get<2>(data_tuple);
          timing_arcs.emplace_back(src_name, src_ipin, port->name, ipin, delay);
        }
      }

      output_port_conns[port->name].push_back(net);
      if (pin->type == PB_PIN_SEQUENTIAL && !std::isnan(pin->tco_max))
        ports_tcq[port->name] = std::make_pair(pin->tco_max, pin->associated_clock_pin->port->name);
    }
  }

  // Process the clock ports
  for (int iport = 0; iport < pb_graph_node->num_clock_ports; ++iport) {
    for (int ipin = 0; ipin < pb_graph_node->num_clock_pins[iport]; ++ipin) {
      const t_pb_graph_pin* pin = &pb_graph_node->clock_pins[iport][ipin];
      const t_port* port = pin->port;

      int cluster_pin_idx = pin->pin_count_in_cluster;

      string net;
      if (!top_pb_route.count(cluster_pin_idx)) {
        // Disconnected
        net = "";
      } else {
        // Connected
        auto atom_net_id = top_pb_route[cluster_pin_idx].atom_net_id;
        assert(atom_net_id);  // Must have a clock

        auto src_tnode = find_tnode(atom, cluster_pin_idx);
        net = make_inst_wire(atom_net_id, src_tnode, inst_name, PortType::CLOCK, iport, ipin);
      }

      input_port_conns[port->name].push_back(net);
    }
  }

  auto& atom_ctx = g_vpr_ctx.atom();
  AtomBlockId blk_id = atom_ctx.lookup.pb_atom(atom);
  for (auto param : atom_ctx.nlist.block_params(blk_id)) {
    params[param.first] = param.second;
  }

  for (auto attr : atom_ctx.nlist.block_attrs(blk_id)) {
    attrs[attr.first] = attr.second;
  }

  return std::make_shared<BlackBoxInst>(type_name, inst_name, params, attrs, input_port_conns,
                                        output_port_conns, timing_arcs, ports_tsu, ports_thld, ports_tcq,
                                        opts_);
}

}

